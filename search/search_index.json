{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroJSON Specification","text":""},{"location":"#introduction","title":"Introduction","text":"<p>MicroJSON is a format, inspired by GeoJSON, for encoding a variety of data structures related to microscopy images, including reference points, regions of interest, and other annotations. These data structures are represented using the widely adopted JSON format, making it easy to work with in various programming languages and applications. It is fully backwards compatible with the GeoJSON Specification, RFC 7946, since any GeoJSON also is accepted as a MicroJSON. As GeoJSON supports foreign top level properties, a MicroJSON is also a valid GeoJSON. This specification describes briefly the objects that exist in GeoJSON, and then in more detail describes the additional objects that are part of MicroJSON. For a more detailed description of the GeoJSON objects, please see the GeoJSON Specification, RFC 7946.</p>"},{"location":"#objects","title":"Objects","text":""},{"location":"#microjson-object","title":"MicroJSON Object","text":"<p>A MicroJSON object is a JSON object that represents a geometry, feature, or collection of features, or more precisely, be either of type (having value of top level field <code>type</code> as) <code>\"Geometry\"</code>, <code>\"Feature\"</code>, or <code>\"Featurecollection\"</code>, that is, the same as for GeoJSON.</p> <p>A MicroJSON object may have a <code>\"bbox\"</code> property\":</p> <ul> <li><code>\"bbox\"</code>: (Optional) Bounding Box of the feature represented as an array of length 4 (2D) or length 6 (3D).</li> </ul>"},{"location":"#geometry-object","title":"Geometry Object","text":"<p>A geometry object is a JSON object where the <code>type</code> member's value is one of the following strings: <code>\"Point\"</code>, <code>\"MultiPoint\"</code>, <code>\"LineString\"</code>, <code>\"MultiLineString\"</code>, <code>\"Polygon\"</code>, <code>\"Rectangle\"</code>, <code>\"MultiPolygon\"</code>, or <code>\"GeometryCollection\"</code>.</p> <p>Each geometry object MUST have a <code>\"coordinates\"</code> member with an array value. The structure of the coordinates array varies with the geometry type.  The innermost point coordinates array MUST contain two or three (if 3D) numbers representing the X and Y (and Z) coordinates of the point in the image. These coordinates follow the same order as the axes in Multiscale object. Please note that these coordinates differ from the GeoJSON specification, where the order is longitude, latitude, and optionally altitude. If no multiscale object is defined, the default coordinate system is assumed to be the same as the image coordinate system, using cartesian coordinates and pixels as units, with the origin at the top left corner of the image, and the x-axis pointing to the right and the y-axis pointing down. The z-axis points into the image, with the origin at the top left corner of the image.</p> <ul> <li>Point:  Must be a single set of point coordinates. A \u201cPoint\u201d Geometry may have a radius, if representing a circular object, with the value in pixels, specified as a member <code>\u201cradius\u201d</code> of the Geometry object.</li> <li>MultiPoint: The coordinates array must be an array of point coordinates.</li> <li>LineString: The coordinates array must be an array of two or more point coordinates forming a continuous line. A \u201cLineString\u201d Geometry may have a radius, with the value in pixels, specified as a member \u201cradius\u201d of the Geometry object.</li> <li>MultiLineString: The coordinates array must be an array of LineString coordinate arrays.</li> <li>Polygon: The coordinates array must be an array of linear ring point coordinate arrays, where the first linear ring represents the outer boundary and any additional rings represent holes within the polygon.<ul> <li>A subtype of \u201cPolygon\u201d is the \u201cRectangle\u201d geometry: A polygon with an array of four 2D point coordinates representing the corners of the rectangle in a counterclockwise order. It has the property subtype with the value <code>\u201cRectangle\u201d</code>.</li> </ul> </li> <li>MultiPolygon: The coordinates array must be an array of Polygon coordinate arrays.</li> </ul>"},{"location":"#geometrycollection","title":"GeometryCollection","text":"<p>A GeometryCollection is an array of geometries (Point, multipoint, LinesString, MultiLineString, Polygon, MultiPolygon). It is possible for this array to be empty.</p>"},{"location":"#feature-object","title":"Feature Object","text":"<p>A feature object represents a spatially bounded entity associated with properties specific to that entity. A feature object is a JSON object with the following members, required unless otherwise noted:</p> <ul> <li><code>\"type\"</code>: A string with the value <code>\"Feature\"</code>.</li> <li><code>\"geometry\"</code>: A geometry object as defined in the section above or a JSON null value.</li> <li><code>\"properties\"</code>: (Optional) A JSON object containing properties and metadata specific to the feature, or a JSON null value. It consists of key-value pairs, where the key is a string and the value is a any JSON value. The value may be a string, number, array, object.</li> <li><code>\"id\"</code>: (Optional) A unique identifier for this feature.</li> <li><code>\"ref\"</code>: (Optional) A reference to an external resource, e.g. URI to a zarr structure, e.g. \"s3://zarr-demo/store/my_array.zarr\".</li> <li><code>\"parentId\"</code>: (Optional) A reference to the parent feature, e.g. the id of the feature that this feature is a part of.</li> <li><code>\"feeatureClass\"</code>: (Optional) A string indicating the class of the feature, e.g. \"cell\", \"nucleus\", \"mitochondria\", etc.</li> </ul>"},{"location":"#special-feature-objects","title":"Special Feature Objects","text":"<ul> <li> <p>Image: An image MUST have the following key-value pairs in its \u201cproperties\u201d object:</p> <ul> <li><code>\"type\"</code>: A string with the value \u201cImage\u201d</li> <li><code>\"URI\"</code>: A string with the image URI, e.g. \u201c./image_1.tif\" An Image MUST also have a geometry object (as its \u201cgeometry\u201d member) of type \"Polygon\", subtype \u201cRectangle\u201d, indicating the shape of the image. An Image may have the following additional key-value pairs in its \u201cproperties\u201d object:</li> <li><code>\"correction\"</code>: A list of coordinates indicating the relative correction of the image, e.g. <code>[1, 2]</code> indicating a correction of 1 units in the x direction and 2 units in the y direction, with units as defined by the coordinate system. If the coordinate system is not defined, the units are pixels.</li> </ul> </li> </ul>"},{"location":"#featurecollection-object","title":"FeatureCollection Object","text":"<p>A FeatureCollection object is a JSON object representing a collection of feature objects. A FeatureCollection object has a member with the name <code>\"features\"</code>. The value of <code>\"features\"</code> is a JSON array. Each element of the array is a Feature object as defined above. It is possible for this array to be empty. Additionally, it may have the following members:</p> <ul> <li><code>\"properties\"</code>: (Optional) A JSON object containing properties and metadata specific to the feature collection, and which apply to all features of the collection, or a JSON null value. It has the same structure as the <code>\"properties\"</code> member of a Feature object.</li> </ul>"},{"location":"#special-featurecollection-objects","title":"Special FeatureCollection Objects","text":"<ul> <li> <p>StitchingVector: Represents a stitching vector, and MUST have the following key-value pairs in its \u201cproperties\u201d object:</p> <ul> <li><code>\"type\"</code>: A string with the value \u201cStitchingVector\u201d</li> </ul> <p>Any object of a StitchingVector \u201cfeatures\u201d array MUST be an \u201cImage\u201d special type of features object.</p> </li> </ul>"},{"location":"about/","title":"About MicroJSON","text":"<p>MicroJSON is a lightweight, human-readable, and easy-to-parse data format for representing geospatial and multidimensional data. It is designed to be simple and efficient, making it suitable for a wide range of applications, from web mapping to scientific data analysis.</p>"},{"location":"example/","title":"MicroJSON Examples","text":""},{"location":"example/#basic-microjson","title":"Basic MicroJSON","text":"<p>This JSON file demonstrates how MicroJSON can be used to define and describe different structures related to imaging, such as cells and their nuclei, including their spatial relationships, identifiers, labels, and color representations.</p> <pre><code>{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n      {\n        \"type\": \"Feature\",\n        \"geometry\": {\n          \"type\": \"Polygon\",\n          \"coordinates\": [[[0.0, 0.0], [0.0, 50.0], [50.0, 50.0], [50.0, 0.0], [0.0, 0.0]]]\n        },\n        \"properties\": {\n            \"well\": \"A1\",\n            \"cellCount\": 5,\n            \"ratioInfectivity\": [0.1, 0.2, 0.3, 0.4, 0.5]\n        }\n      },\n      {\n        \"type\": \"Feature\",\n        \"geometry\": {\n          \"type\": \"Polygon\",\n          \"coordinates\": [[[50.0, 0.0], [50.0, 50.0], [100.0, 50.0], [100.0, 0.0], [50.0, 0.0]]]\n        },\n        \"properties\": {\n            \"well\": \"A2\",\n            \"cellCount\": 10,\n            \"ratioInfectivity\": [0.1, 0.2, 0.3, 0.4, 0.5]\n        }\n      }\n    ]\n  }\n</code></pre>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2024 PolusAI</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"metadata_example/","title":"Metadata Usage in MicroJSON Example","text":"<p>This guide demonstrates how to designate metadata in MicroJSON using the <code>properties</code> field in the <code>Feature</code> class. The <code>properties</code> field is used to store metadata related to a feature. This guide provides examples of how to populate these fields in both JSON and Python.</p> <p>Now, let's explore an example to understand how these fields can be populated in both JSON and Python.</p>"},{"location":"metadata_example/#json-example","title":"JSON Example","text":"<pre><code>{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n      [\n        [100.0, 0.0],\n        [101.0, 0.0],\n        [101.0, 1.0],\n        [100.0, 1.0],\n        [100.0, 0.0]\n      ]\n    ]\n  },\n  \"properties\": {\n    \"string\": {\n      \"name\": \"Sample Polygon\",\n      \"description\": \"This is a sample rectangular polygon.\"\n    },\n    \"numeric\": {\n      \"cellCount\": 5000\n    },\n    \"multiNumeric\": {\n      \"ratioInfectivity\": [0.2, 0.5, 0.8]\n    }\n  }\n}\n</code></pre>"},{"location":"metadata_example/#python-example","title":"Python Example","text":"<pre><code>from microjson.model import MicroFeature, Properties\n\n# Usage\nexample_properties = {\n  \"name\": \"Sample Polygon\",\n  \"description\": \"This is a sample rectangular polygon.\",\n  \"cellCount\": 5000,\n  \"ratioInfectivity\": [0.2, 0.5, 0.8]\n}\n\nexample_feature = MicroFeature(\n    type=\"Feature\",\n    geometry={\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [100.0, 0.0],\n                [101.0, 0.0],\n                [101.0, 1.0],\n                [100.0, 1.0],\n                [100.0, 0.0]\n            ]\n        ]\n    },\n    properties=example_properties\n)\n# print json\nprint(example_feature.model_dump_json(indent=2, exclude_unset=True))\n</code></pre> <p>In this example, a MicroJSON feature is defined with a rectangular polygon geometry, and the <code>Properties</code> class from the <code>microjson.model</code> module is employed to encapsulate string, numeric, and multiNumeric metadata associated with the feature. The JSON representation offers a clear formatting of the data, while the Python script showcases how to instantiate the <code>Properties</code> and <code>MicroFeature</code> classes to encapsulate the same data.</p>"},{"location":"ome/","title":"Extending OME-NGFF with Tiled Data Models: Integrating TileJSON, MicroJSON, and Vector Tiling","text":""},{"location":"ome/#introduction","title":"Introduction","text":"<p>OME Next-Generation File Format is a format for storing bioimaging data in the cloud, for which there is a growing need to integrate with established vector tiling formats widely used in geospatial applications. Vector tiling formats like Mapbox Vector Tiles (MVT) and MicroJSON  and tiling descriptors like TileJSON, which has been adapted to MicroJSON provide a standardized way to access and visualize large geospatial datasets. This document explores how these tiling models can be integrated with OME-NGFF.</p> <p>The TileJSON serves as a endpoint mapping that can bridge between NGFF\u2019s chunked multiscale data structures and other tiling models. Tiles may then be of different formats:</p> <ul> <li>MicroJSON: MicroJSON may be used for each tile, using its intrinsic coordinate system to annotate the features of the tile.</li> <li>JSON Vector tiles: JSON representations of vector data, like Mapbox Vector Tiles (MVT) in JSON format.</li> <li>Binary tile formats encoded either like Mapbox Vector Tiles (MVT, protobuf-encoded tiles), or GeoParquet (Apache Parquet-based vector tiles).</li> </ul>"},{"location":"ome/#background-ome-ngff","title":"Background: OME-NGFF","text":"<p>OME-NGFF provides a standardized way to store large image datasets (in for example Zarr format) with metadata describing scale transformations, coordinate systems, and multiple resolution levels. Each resolution level consists of a set of chunked arrays, allowing efficient partial retrieval and processing of large images by tiled raster data.</p> <p>Key features of NGFF:</p> <ul> <li>Multidimensional data (2-5D):  time (t), channel (c), z-depth (z), and spatial dimensions (y, x).</li> <li>Multiscale pyramids, each level providing a different resolution.  </li> <li>Flexible coordinate transformations that can place data in a variety of coordinate reference systems (CRS).</li> </ul>"},{"location":"ome/#tilejson-as-an-endpoint-mapping-layer","title":"TileJSON as an endpoint mapping Layer","text":"<p>TileJSON is a well-established specification within the geospatial community that describes tiled data sources via a simple JSON schema. It is commonly used in web mapping to:</p> <ul> <li>Reference a set of tiled resources (raster or vector) defined by zoom levels and tile coordinates (z/x/y). The standard order differs from NGFF\u2019s (z/y/x).</li> <li>Provide metadata such as bounding boxes, attribution, min/max zoom levels, and tile endpoints.</li> </ul> <p>While TileJSON has traditionally been used in 2D applications, there is nothing that hinders it from being used with higher dimensions, including 5D as with NGFF. The MicroJSON implementation of TileJSON outlines such usage. It thus can be used to map endpoints for a coordinate system that is not strictly geospatial, given the following:</p> <ol> <li>NGFF\u2019s multiscale pyramids could be mapped directly to TileJSON\u2019s <code>zoom</code> levels, however, TileJSON assumes a zoom factor of 2, while NGFF may have arbitrary scale factors. This may require additional adaptions of the TileJSON schema, to allow for arbitrary scale factors. This could be done by defining a new <code>scale_factor</code> field in the TileJSON schema. Followingly, the <code>Multiscale</code> class in the MicroJSON should be moved to the TileJSON schema.</li> <li>Associate NGFF array chunks with tile indices (z/x/y) derived from spatial transformations, given the NGFF multiscale metadata and the corresponding TileJSON metadata.</li> <li>A practical observation is that if the multiscale pyramids differs, transformations between the two systems are needed, in addition to what is described above, which could be avoided by using the same multiscale pyramid structure in both systems. This is also valid for the tile size (expressed in the global coordinates), which should be the same in both systems for a specific zoom level.</li> <li>Layering of data is supported in TileJSON, as the array <code>vector_layers</code> in its schema. Layers are thus stored together for each tile, as a contrast to the NGFF, where the layers are stored in separate arrays as labeled images.</li> <li>The NGFF raster data hierarchy could be expressed with a TileJSON which does not have a vector layer but instead just maps the raster data endpoints as formatted in the field <code>tiles</code> in the TileJSON schema.</li> </ol>"},{"location":"ome/#incorporating-microjson-and-vector-tiles","title":"Incorporating MicroJSON and Vector Tiles","text":"<p>MicroJSON is a valid GeoJSON but with a few extra additions, including for example feature classes and parent-relations between features. It aligns well with TileJSON as individual tiles could be specified in MicroJSON, but with the same agnostic coordinate system as for the binary vector tiles, and the intermediate vector tile JSON.</p> <p>Vector Tiles is a binary format for encoding vector data in tiles, either using protobuf, or directly as vector tile JSON, or some other format, like GeoParquet. Protobuf is widely used in geospatial applications to express them in  compact form. The MVT format can be used to represent vector data in a tile-based system, with each tile containing a subset of the vector data. The MVT format is well-suited for representing vector data in a tile-based system, as it allows for efficient storage and retrieval of vector data.</p>"},{"location":"ome/#ngff-labels-and-vector-tiles","title":"NGFF Labels and Vector Tiles","text":"<p>NGFF labels can be represented as vector tiles, where each tile contains a subset of the labels. This allows for efficient storage and retrieval of labels, as well as the ability to overlay labels on top of raster data. The vector tiles can be stored in a tile-based system, with each tile containing a subset of the labels. This allows for efficient storage and retrieval of labels, as well as the ability to overlay labels on top of raster data. If desired, the labels can be stored both as raster data and as vector tiles, allowing for flexibility in how the labels are displayed for different tools and applications. It is strongly suggested to use the same identifier for the labels in the NGFF and the vector tiles, to allow for easy integration between the two systems.</p>"},{"location":"ome/#conclusion","title":"Conclusion","text":"<p>TileJSON may be used as a bridge between OME-NGFF and individual vector tiles, expressed in different formats. For practical use, it is optimal if zoom levels and tile sizes are consistent between the two systems. such as MicroJSON and vector tiles. The integration of these tiling models can provide a standardized way to access and visualize large geospatial datasets, while also allowing for the efficient storage and retrieval of vector data. By aligning the coordinate reference systems and handling higher-dimensional data through slicing or conventions, it is possible to create a seamless integration between OME-NGFF and other tiling models. Vector tiles may replace the NGFF labels, although they can be stored in parallel for flexibility.</p> <p>The current version of MicroJSON must be adapted to support the NGFF data model, and the TileJSON schema should be extended to support arbitrary scale factors.</p>"},{"location":"provenance/","title":"Provenance and Traceability in MicroJSON","text":""},{"location":"provenance/#background","title":"Background","text":"<p>For geospatial data, particularly with GeoJSON, there are no standardized methods for tracing data provenance. While GeoJSON offers a robust format for geographical features representation, it lacks mechanisms for tracking the workflows and processes that generate or modify these features. This document outlines an addition to MicroJSON, integrating a provenance model to bridge this gap.</p>"},{"location":"provenance/#design-motivations","title":"Design Motivations","text":"<p>The design introduces a traceability model that integrates seamlessly with MicroJSON, enhancing GeoJSON capabilities while maintaining full backward compatibility. Key motivations include:</p> <ul> <li>Supporting Workflow Integration: Linking MicroJSON objects to specific analytical workflows, thereby enabling reproducibility and transparency.</li> <li>Enabling Flexible Provenance Tracking: Providing detailed information about workflow steps, including input and output parameters, that led to the creation or modification of MicroJSON objects.</li> <li>Facilitating Workflow and Artifact Linking: Allowing references to specific workflows and artifacts, providing a comprehensive view of data processing and provenance tracking.</li> <li>Adapting to Varied Use Cases: Accommodating both structured and ad-hoc processes.</li> </ul>"},{"location":"provenance/#model-structure","title":"Model Structure","text":"<p>The provenance model structure comprises <code>WorkflowCollection</code>, <code>Workflow</code>, <code>Artifact</code>, <code>ArtifactCollection</code>, <code>WorkflowProvenance</code>, and <code>MicroJSONLink</code> objects:</p> <ul> <li>Workflow Collection Object: Includes multiple workflows, acknowledging that a single MicroJSON object might result from various processes.</li> <li>Workflow Object: Captures essential workflow details, including identifiers and descriptive metadata. This metadata links MicroJSON objects to their respective workflows.</li> <li>Artifact and Artifact Collection Objects: Represent single files or directories and collections of these, respectively, providing a link between the physical data and the workflows.</li> <li>Workflow Provenance Object: Details specific instances of workflow runs, including run identifiers, duration, operator, and the input/output parameters. Of these, Workflow, WorkflowCollection, Artifact, and ArtifactCollection can function as the top object in the provenance part of a MicroJSON file.</li> <li>MicroJSON Link Object: Provides a link to a specific MicroJSON object, specifying which parts of the object's properties are pertinent to the workflow run. While this object is required, and the id property is required, the specification of a field in the MicroJSON object is optional. If no field is specified, the entire MicroJSON object is considered to be pertinent to the workflow run or artifact.</li> </ul>"},{"location":"provenance/#data-provenance-and-microjson-traceability-link","title":"Data Provenance and MicroJSON Traceability Link","text":"<p>Under each workflow, the <code>WorkflowProvenance</code> object includes:</p> <ul> <li>Properties that describe the workflow run, in form of a dictionary, to enable flexible and scalable provenance tracking. Example of properties include run identifier, duration, operator, and input/output parameters.</li> <li>Output Artifacts: These artifacts are the result of the workflow run. These in turn has the <code>microjsonLinks</code> field, which is a list of MicroJSON objects that is pertinent to the workflow run:</li> <li>MicroJSON Traceability Links: These links connect back to specific MicroJSON objects, specifying which parts of the object's properties are pertinent to the workflow run.</li> </ul>"},{"location":"provenance/#rationale-for-structure","title":"Rationale for Structure","text":"<p>This structure is designed to:</p> <ul> <li>Reflect Complex Data Relationships: Multiple workflows can contribute to a single MicroJSON object.</li> <li>Provide Comprehensive Traceability: Offering a complete journey of the data from origin through processing steps.</li> <li>Ensure Flexibility and Scalability: Suitable for a wide range of scenarios and scalable in applications.</li> <li>Capture Simple Provenance: Allowing for simple provenance tracking, such as a single standalone workflow or even only an artifact or artifact collection. This enhancement not only increases the utility of MicroJSON in various scientific and geospatial contexts but also fosters an environment of transparency and reproducibility.</li> </ul>"},{"location":"provenance/#examples-microjson-provenance-and-traceability","title":"Examples MicroJSON Provenance and Traceability","text":"<p>Example 1: MicroJSON with single Artifact only</p> <pre><code>{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"id\": \"1\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"subtype\": \"Rectangle\",\n                \"coordinates\": [\n                    [\n                        [\n                            0.0,\n                            0.0\n                        ],\n                        [\n                            0.0,\n                            50.0\n                        ],\n                        [\n                            50.0,\n                            50.0\n                        ],\n                        [\n                            50.0,\n                            0.0\n                        ],\n                        [\n                            0.0,\n                            0.0\n                        ]\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"string\": {\n                    \"well\": \"A1\"\n                },\n                \"numeric\": {\n                    \"cellCount\": 5\n                },\n                \"multiNumeric\": {\n                    \"ratioInfectivity\": [\n                        [\n                            0.1,\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5\n                        ],\n                        [\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5,\n                            0.6\n                        ]\n                    ]\n                }\n            }\n        },\n        {\n            \"type\": \"Feature\",\n            \"id\": \"2\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"subtype\": \"Rectangle\",\n                \"coordinates\": [\n                    [\n                        [\n                            50.0,\n                            0.0\n                        ],\n                        [\n                            50.0,\n                            50.0\n                        ],\n                        [\n                            100.0,\n                            50.0\n                        ],\n                        [\n                            100.0,\n                            0.0\n                        ],\n                        [\n                            50.0,\n                            0.0\n                        ]\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"string\": {\n                    \"well\": \"A2\"\n                },\n                \"numeric\": {\n                    \"cellCount\": 10\n                },\n                \"multiNumeric\": {\n                    \"ratioInfectivity\": [\n                        [\n                            0.1,\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5\n                        ],\n                        [\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5,\n                            0.6\n                        ]\n                    ]\n                }\n            }\n        }\n    ],\n    \"provenance\": {\n        \"type\": \"Artifact\",\n        \"id\": \"artifact_1\",\n        \"uri\": \"file://path/to/image.tif\",\n        \"properties\": {\n            \"imageType\": \"TIFF\",\n            \"analysisType\": \"Cell counting\"\n        },\n        \"microjsonLinks\": [\n            {\n                \"microjsonTd\": \"1\",\n                \"microjsonField\": \"string.well\"\n            }\n        ]\n    }\n}\n</code></pre> <p>Example 2: MicroJSON with Workflow Collection</p> <pre><code>{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"id\": \"1\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"subtype\": \"Rectangle\",\n                \"coordinates\": [\n                    [\n                        [\n                            0.0,\n                            0.0\n                        ],\n                        [\n                            0.0,\n                            50.0\n                        ],\n                        [\n                            50.0,\n                            50.0\n                        ],\n                        [\n                            50.0,\n                            0.0\n                        ],\n                        [\n                            0.0,\n                            0.0\n                        ]\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"string\": {\n                    \"well\": \"A1\"\n                },\n                \"numeric\": {\n                    \"cellCount\": 5\n                },\n                \"multiNumeric\": {\n                    \"ratioInfectivity\": [\n                        [\n                            0.1,\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5\n                        ],\n                        [\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5,\n                            0.6\n                        ]\n                    ]\n                }\n            }\n        },\n        {\n            \"type\": \"Feature\",\n            \"id\": \"2\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"subtype\": \"Rectangle\",\n                \"coordinates\": [\n                    [\n                        [\n                            50.0,\n                            0.0\n                        ],\n                        [\n                            50.0,\n                            50.0\n                        ],\n                        [\n                            100.0,\n                            50.0\n                        ],\n                        [\n                            100.0,\n                            0.0\n                        ],\n                        [\n                            50.0,\n                            0.0\n                        ]\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"string\": {\n                    \"well\": \"A2\"\n                },\n                \"numeric\": {\n                    \"cellCount\": 10\n                },\n                \"multiNumeric\": {\n                    \"ratioInfectivity\": [\n                        [\n                            0.1,\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5\n                        ],\n                        [\n                            0.2,\n                            0.3,\n                            0.4,\n                            0.5,\n                            0.6\n                        ]\n                    ]\n                }\n            }\n        }\n    ],\n    \"provenance\": {\n        \"type\": \"WorkflowCollection\",\n        \"workflows\": [\n            {\n                \"type\": \"Workflow\",\n                \"id\": \"workflow_1\",\n                \"properties\": {\n                    \"description\": \"Image processing workflow\"\n                },\n                \"sub_workflows\": [],\n                \"workflow_provenance\": {\n                    \"type\": \"WorkflowProvenance\",\n                    \"output_artifacts\": {\n                        \"type\": \"Artifact\",\n                        \"id\": \"artifact_1\",\n                        \"uri\": \"file://path/to/image.tif\",\n                        \"properties\": {\n                            \"imageType\": \"TIFF\",\n                            \"analysisType\": \"Cell counting\"\n                        },\n                        \"microjsonLinks\": [\n                            {\n                                \"microjsonId\": \"1\",\n                                \"microjsonField\": \"string.well\"\n                            }\n                        ]\n                    }\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"pydantic/","title":"Pydantic Models for MicroJSON and GeoJSON","text":""},{"location":"pydantic/#introduction","title":"Introduction","text":"<p>This document describes the Pydantic models used for GeoJSON and MicroJSON objects. These models leverage Python's type hinting and Pydantic's validation mechanisms, making it robust and efficient to work with complex GeoJSON and MicroJSON objects.</p>"},{"location":"pydantic/#models","title":"Models","text":"<p>MicroJSON and GeoJSON models, defined manually using pydantic.</p>"},{"location":"pydantic/#microjson.model.GeoJSON","title":"<code>GeoJSON</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>The root object of a GeoJSON file</p> Source code in <code>src/microjson/model.py</code> <pre><code>class GeoJSON(RootModel):\n    \"\"\"The root object of a GeoJSON file\"\"\"\n\n    root: Union[Feature, FeatureCollection, GeometryType]  # type: ignore\n</code></pre>"},{"location":"pydantic/#microjson.model.MicroFeature","title":"<code>MicroFeature</code>","text":"<p>               Bases: <code>Feature</code></p> <p>A MicroJSON feature, which is a GeoJSON feature with additional metadata</p> <p>Parameters:</p> Name Type Description Default <code>multiscale</code> <code>Optional[Multiscale]</code> <p>The coordinate system of the feature</p> required <code>ref</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>A reference to the parent feature</p> required <code>parentId</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>A reference to the parent feature</p> required <code>featureClass</code> <code>Optional[str]</code> <p>The class of the feature</p> required Source code in <code>src/microjson/model.py</code> <pre><code>class MicroFeature(Feature):\n    \"\"\"A MicroJSON feature, which is a GeoJSON feature with additional\n    metadata\n\n    Args:\n        multiscale (Optional[Multiscale]): The coordinate system of the feature\n        ref (Optional[Union[StrictStr, StrictInt]]):\n            A reference to the parent feature\n        parentId (Optional[Union[StrictStr, StrictInt]]):\n            A reference to the parent feature\n        featureClass (Optional[str]): The class of the feature\n    \"\"\"\n\n    ref: Optional[Union[StrictStr, StrictInt]] = None\n    # reference to the parent feature\n    parentId: Optional[Union[StrictStr, StrictInt]] = None\n    # for now, only string feature class is supported\n    # in the future, it may be expanded with a class registry\n    featureClass: Optional[str] = None\n</code></pre>"},{"location":"pydantic/#microjson.model.MicroFeatureCollection","title":"<code>MicroFeatureCollection</code>","text":"<p>               Bases: <code>FeatureCollection</code></p> <p>A MicroJSON feature collection, which is a GeoJSON feature collection with additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Optional[Props]</code> <p>The properties of the feature collection</p> required <code>id</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>The ID of the feature coll.</p> required Source code in <code>src/microjson/model.py</code> <pre><code>class MicroFeatureCollection(FeatureCollection):\n    \"\"\"A MicroJSON feature collection, which is a GeoJSON feature\n    collection with additional metadata.\n\n    Args:\n        properties (Optional[Props]): The properties of the feature collection\n        id (Optional[Union[StrictStr, StrictInt]]): The ID of the feature coll.\n        provenance (Optional[Union[Workflow,\n            WorkflowCollection,\n            Artifact,\n            ArtifactCollection]]): The provenance of the feature collection\n    \"\"\"\n\n    properties: Optional[Union[Props, None]] = None  # type: ignore\n    id: Optional[Union[StrictStr, StrictInt]] = None\n    provenance: Optional[Union[Workflow,\n                               WorkflowCollection,\n                               Artifact,\n                               ArtifactCollection]] = None\n</code></pre>"},{"location":"pydantic/#microjson.model.MicroJSON","title":"<code>MicroJSON</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>The root object of a MicroJSON file</p> Source code in <code>src/microjson/model.py</code> <pre><code>class MicroJSON(RootModel):\n    \"\"\"The root object of a MicroJSON file\"\"\"\n\n    root: Union[MicroFeature,  # type: ignore\n                MicroFeatureCollection,\n                GeometryType]\n</code></pre>"},{"location":"pydantic/#base-objects","title":"Base Objects","text":""},{"location":"pydantic/#geometry-types","title":"Geometry Types","text":"<p>Uses geojson-pydantic models for GeoJSON geometry types, included here for reference. Please refer to the geojson-pydantic documentation for more information.</p>"},{"location":"pydantic/#point","title":"Point","text":"<p>Represents a GeoJSON Point object.</p>"},{"location":"pydantic/#multipoint","title":"MultiPoint","text":"<p>Represents a GeoJSON MultiPoint object.</p>"},{"location":"pydantic/#linestring","title":"LineString","text":"<p>Represents a GeoJSON LineString object.</p>"},{"location":"pydantic/#multilinestring","title":"MultiLineString","text":"<p>Represents a GeoJSON MultiLineString object.</p>"},{"location":"pydantic/#polygon","title":"Polygon","text":"<p>Represents a GeoJSON Polygon object.</p>"},{"location":"pydantic/#multipolygon","title":"MultiPolygon","text":"<p>Represents a GeoJSON MultiPolygon object.</p>"},{"location":"pydantic/#compound-objects","title":"Compound Objects","text":""},{"location":"pydantic/#geometrycollection","title":"GeometryCollection","text":"<p>A collection of multiple geometries. From geojson-pydantic, included here for reference.</p>"},{"location":"pydantic/#feature","title":"Feature","text":"<p>Represents a GeoJSON feature object, from geojson-pydantic, included here for reference.</p>"},{"location":"pydantic/#featurecollection","title":"FeatureCollection","text":"<p>Represents a GeoJSON feature collection, from geojson-pydantic, included here for reference.</p>"},{"location":"pydantic/#geojson","title":"GeoJSON","text":"<p>The root object of a GeoJSON file.</p> <p>               Bases: <code>RootModel</code></p> <p>The root object of a GeoJSON file</p> Source code in <code>src/microjson/model.py</code> <pre><code>class GeoJSON(RootModel):\n    \"\"\"The root object of a GeoJSON file\"\"\"\n\n    root: Union[Feature, FeatureCollection, GeometryType]  # type: ignore\n</code></pre>"},{"location":"pydantic/#microjson-extended-models","title":"MicroJSON Extended Models","text":""},{"location":"pydantic/#microfeature","title":"MicroFeature","text":"<p>A MicroJSON feature, which is an extension of a GeoJSON feature.</p> <p>               Bases: <code>Feature</code></p> <p>A MicroJSON feature, which is a GeoJSON feature with additional metadata</p> <p>Parameters:</p> Name Type Description Default <code>multiscale</code> <code>Optional[Multiscale]</code> <p>The coordinate system of the feature</p> required <code>ref</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>A reference to the parent feature</p> required <code>parentId</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>A reference to the parent feature</p> required <code>featureClass</code> <code>Optional[str]</code> <p>The class of the feature</p> required Source code in <code>src/microjson/model.py</code> <pre><code>class MicroFeature(Feature):\n    \"\"\"A MicroJSON feature, which is a GeoJSON feature with additional\n    metadata\n\n    Args:\n        multiscale (Optional[Multiscale]): The coordinate system of the feature\n        ref (Optional[Union[StrictStr, StrictInt]]):\n            A reference to the parent feature\n        parentId (Optional[Union[StrictStr, StrictInt]]):\n            A reference to the parent feature\n        featureClass (Optional[str]): The class of the feature\n    \"\"\"\n\n    ref: Optional[Union[StrictStr, StrictInt]] = None\n    # reference to the parent feature\n    parentId: Optional[Union[StrictStr, StrictInt]] = None\n    # for now, only string feature class is supported\n    # in the future, it may be expanded with a class registry\n    featureClass: Optional[str] = None\n</code></pre>"},{"location":"pydantic/#microfeaturecollection","title":"MicroFeatureCollection","text":"<p>A MicroJSON feature collection, which is an extension of a GeoJSON feature collection.</p> <p>               Bases: <code>FeatureCollection</code></p> <p>A MicroJSON feature collection, which is a GeoJSON feature collection with additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Optional[Props]</code> <p>The properties of the feature collection</p> required <code>id</code> <code>Optional[Union[StrictStr, StrictInt]]</code> <p>The ID of the feature coll.</p> required Source code in <code>src/microjson/model.py</code> <pre><code>class MicroFeatureCollection(FeatureCollection):\n    \"\"\"A MicroJSON feature collection, which is a GeoJSON feature\n    collection with additional metadata.\n\n    Args:\n        properties (Optional[Props]): The properties of the feature collection\n        id (Optional[Union[StrictStr, StrictInt]]): The ID of the feature coll.\n        provenance (Optional[Union[Workflow,\n            WorkflowCollection,\n            Artifact,\n            ArtifactCollection]]): The provenance of the feature collection\n    \"\"\"\n\n    properties: Optional[Union[Props, None]] = None  # type: ignore\n    id: Optional[Union[StrictStr, StrictInt]] = None\n    provenance: Optional[Union[Workflow,\n                               WorkflowCollection,\n                               Artifact,\n                               ArtifactCollection]] = None\n</code></pre>"},{"location":"pydantic/#microjson","title":"MicroJSON","text":"<p>The root object of a MicroJSON file.</p> <p>               Bases: <code>RootModel</code></p> <p>The root object of a MicroJSON file</p> Source code in <code>src/microjson/model.py</code> <pre><code>class MicroJSON(RootModel):\n    \"\"\"The root object of a MicroJSON file\"\"\"\n\n    root: Union[MicroFeature,  # type: ignore\n                MicroFeatureCollection,\n                GeometryType]\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Below is a high-level roadmap for the development of MicroJSON. The roadmap is divided into four phases, each focusing on different aspects of the project. The goal is to gradually expand the capabilities of MicroJSON, engage with the community, and establish a sustainable development model. The below roadmap is subject to change based on feedback and evolving requirements.</p>"},{"location":"roadmap/#phase-1-consolidation-and-documentation","title":"Phase 1: Consolidation and Documentation","text":"<ol> <li> <p>Refinement of Core Model:</p> <ul> <li>Finalize and stabilize the current MicroJSON core model.</li> <li>Update according to feedback from key stakeholders and users.</li> <li>Publish updated documentation and specifications.</li> <li>Implement hierarchical references.</li> </ul> </li> <li> <p>Initial Community Engagement:</p> <ul> <li>Reach out to further potential users and stakeholders to gather feedback and requirements.</li> <li>Establish a communication channel for ongoing discussions and updates, using GitHub issues.</li> </ul> </li> </ol>"},{"location":"roadmap/#phase-2-expanded-features-and-extensions","title":"Phase 2: Expanded Features and Extensions","text":"<ol> <li> <p>Harmonization with GeoJSON Pydantic:</p> <ul> <li>Investigate potential compatibility and dependency with GeoJSON Pydantic.</li> </ul> </li> <li> <p>Harmonization with OME Model:</p> <ul> <li>Harmonize MicroJSON with the OME model for coordinate systems and metadata.</li> </ul> </li> <li> <p>TypeScript and Java reference implementations:</p> <ul> <li>Develop reference implementations in TypeScript and Java to demonstrate the use of MicroJSON in different programming languages.</li> <li>Provide tools and libraries for working with MicroJSON data in these languages.</li> </ul> </li> <li> <p>Tiling with TileJSON and binary formats:</p> <ul> <li>Create a use case with TileJSON, including MicroJSON for tiling.</li> <li>Implement vector tile binary format tooling for exporting to and from MicroJSON.</li> </ul> </li> </ol>"},{"location":"roadmap/#phase-3-3d-and-multidimensional-data","title":"Phase 3: 3D and Multidimensional Data","text":"<ol> <li>2.5D - 2D slices with tiling to build 3D:<ul> <li>Explore the representation of 3D and multidimensional data in MicroJSON.</li> <li>Start with 3D geometries that consist of multiple 2D slices, with tiling support.</li> </ul> </li> <li>General 3D Data Model:<ul> <li>Define a general 3D data mesh model that can represent complex 3D structures.</li> <li>Investigate tilings for scalable 3D data representation.</li> </ul> </li> </ol>"},{"location":"roadmap/#phase-4-adoptopm-amd-long-term-sustainability","title":"Phase 4: Adoptopm amd long-term sustainability","text":"<ol> <li> <p>Case Studies and How-To Guides:</p> <ul> <li>Document and publish case studies demonstrating the use of MicroJSON in key applications.</li> <li>Encourage the development of real-world applications utilizing MicroJSON by providing how-to guides and tutorials.</li> </ul> </li> <li> <p>Establish Governance and Standards Process:</p> <ul> <li>Set up a governance model for the ongoing development and maintenance of MicroJSON.</li> <li>Establish a process for standardizing and accepting new features or extensions.</li> <li>Set up user meetings with regular intervals to gather feedback and discuss future directions, based on technological advancements and user feedback.</li> </ul> </li> </ol>"},{"location":"tiling/","title":"Integration of TileJSON with MicroJSON","text":""},{"location":"tiling/#purpose","title":"Purpose","text":"<p>This specification outlines how to use TileJSON to integrate tiled MicroJSON data, both in json form as well as binary form. It provides examples of how TileJSON can be used to specify the tiling scheme and zoom levels for MicroJSON data and its binary equievalent. It is based on the TileJSON 3.0.0 specification, but extends it by recommending additional properties to enable integration of MicroJSON data and fit purposes of microscopy imaging. The recommendations provided here are not intrinsic to the original TileJSON specification but have been tailored to suit the needs of microscopy metadata annotation and integration with MicroJSON. However, all suggestions are designed to maintain compatibility with the original TileJSON specification.</p>"},{"location":"tiling/#background-of-tilejson","title":"Background of TileJSON","text":"<p>TileJSON is a widely-used format in mapping applications for specifying tilesets. Developed to streamline the integration of different map layers, TileJSON is essential for ensuring consistency across mapping platforms. It describes tilesets through a JSON object, detailing properties like tile URLs, zoom levels, and spatial coverage.</p>"},{"location":"tiling/#tilejson-for-microjson-object-structure","title":"TileJSON for MicroJSON Object Structure","text":"<ul> <li><code>tilejson</code>: Specifies the version of the TileJSON spec being used. Required for all TileJSON objects.</li> <li><code>name</code>: The name of the tileset. Optional but recommended.</li> <li><code>description</code>: Provide a brief description of the tileset. Optional but recommended.</li> <li><code>version</code>: The version of the tileset. Optional but recommended.</li> <li><code>attribution</code>: A link to the data source or other attribution information, e.g. organisational origin. Optional but recommended.</li> <li><code>tiles</code>: Required. The URL pattern for accessing the vector tiles. The  <code>urlbase/{zlvl}/{t}/{c}/{z}/{x}/{y}</code> is the recommended default naming pattern for the tiles, in this order, where <code>urlbase</code> is the base URL (e.g. <code>http://example.com/tiles</code>), <code>{zlvl}</code> is the zoom level, <code>{t}</code> is the tileset timestamp, <code>{c}</code> is the channel, <code>{z}</code> is the z coordinate, and <code>{x}</code> and <code>{y}</code> are the x and y coordinates, respectively. If not using a timestamp, channel, or z coordinate, these can be omitted. The zoom level should always be first.</li> <li><code>minzoom</code> and <code>maxzoom</code>: Defines the range of zoom levels for which the tiles are available.</li> <li><code>bounds</code>: Optional. Specifies the geometrical bounds included in the tileset. Specified as an array of minimum four numbers in the order <code>[minX, minY, maxX, maxY]</code>, but may include up to a further six numbers for a total of ten, <code>[minT, minC, minZ, minX, minY, maxT, maxC, maxZ, maxX, maxY]</code>, where <code>minT</code> is the minimum tileset timestamp, <code>minC</code> is the minimum channel, <code>minZ</code> is the minimum z coordinate, <code>minX</code> and <code>minY</code> are the minimum x and y coordinates, <code>maxT</code> is the maximum tileset timestamp, <code>maxC</code> is the maximum channel, <code>maxZ</code> is the maximum z coordinate, and <code>maxX</code> and <code>maxY</code> are the maximum x and y coordinates.</li> <li><code>center</code>: Optional. Indicates the center and suggested default view of the tileset. Minimum of three numbers in the order <code>[x, y, zoom]</code>, but may include up to a further three numbers for a total of six, <code>[t,c,z,x,y,zoom]</code>, where <code>t</code> is the tileset timestamp, <code>c</code> is the channel, <code>z</code> is the z coordinate, <code>x</code> and <code>y</code> are the x and y coordinates, and <code>zoom</code> is the zoom level. Zoom level should be last.</li> <li> <p><code>vector_layers</code>:  Required. Describes each layer within the vector tiles, and has the following structure:</p> </li> <li> <p><code>id</code>: Required. A unique identifier for the layer. Required for each layer.</p> </li> <li><code>fields</code>: Required. A list of fields (attributes) and their data types. For MicroJSON, this can either be an empty list, or a simple datatype indicator, that is either of <code>String</code>, <code>Number</code>, or <code>Bool</code>. Complex data types, such as arrays or objects are not allowed.  Required for each layer.</li> <li><code>fieldranges</code>: Optional. A dictionary of field names and their ranges. For example, <code>{\"label\": [0,100], \"channel\": [0,10]}</code>. Optional.</li> <li><code>fieldenums</code>: Optional. A dictionary of field names and their possible values. For example, <code>{\"plate\": [\"A1\", \"A2\", \"B1\", \"B2\"], \"image\": [\"image1.tif\", \"image2.tif\", \"image3.tif\"]}</code>. Optional.</li> <li><code>fielddescriptions</code>: Optional. A dictionary of field names and their descriptions. For example, <code>{\"plate\": \"Well plate identifier\", \"image\": \"Image filename\", \"label\": \"Label identifier\", \"channel\": \"Channel identifier\"}</code>. Optional.</li> <li><code>description</code>: Optional. A brief description of the layer.</li> <li><code>minzoom</code> and <code>maxzoom</code>: Optional. The range of zoom levels at which the layer is visible.</li> <li><code>fillzoom</code>: Optional. An integer specifying the zoom level from which to generate overzoomed tiles.</li> <li><code>legend</code>: Optional. Contains a legend to be displayed with the tileset.</li> <li><code>multiscale</code>: Optional. A multiscale object as defined in the section Multiscale Object. If this property is not present, the default coordinate system is assumed to be the same as the image coordinate system, using cartesian coordinates and pixels as units.</li> <li><code>scale_factor</code>: Optional. A float specifying the scale factor for the tileset. If not present, the default value of 2 is assumed. Unless the use case requires a different scale factor, it is highly recommended to use the default value, as it is widely supported and assumed by many viewers.</li> </ul> <p>The following fields of TileJSON may be used if the use case requires it, and are included here for completeness:</p> <ul> <li><code>scheme</code>: The tiling scheme of the tileset.</li> <li><code>grids</code>: The URL pattern for accessing grid data.</li> <li><code>data</code>: Optional. The URL pattern for accessing data. Used for GeoJSON originally, which in this specification is replaced by MicroJSON and used in the <code>tiles</code> field.</li> <li><code>template</code>: Optional. Contains a mustache template to be used to format data from grids for interaction.</li> </ul>"},{"location":"tiling/#multiscale-object","title":"Multiscale Object","text":"<p>A multiscale object represents the choice of axes (2-5D) and potentially their transformations that should be applied to the numerical data in order to arrive to the actual size of the object described. If the field is present, it MUST have the following properties:</p> <ul> <li><code>\"axes\"</code>: Representing the choice of axes as an array of Axis objects.</li> </ul> <p>It may contain either of, but NOT both of the following properties:</p> <ul> <li><code>\"coordinateTransformations\"</code>: Representing the set of coordinate transformations that should be applied to the numerical data in order to arrive to the actual size of the object described. It MUST be an array of objects, each object representing a coordinate transformation. Each object MUST have properties as follows:</li> <li><code>\"type\"</code>: Representing the type of the coordinate transformation. Currently supported types are <code>\"identity\"</code>, <code>\"scale\"</code>, and <code>\"translate\"</code>. If the type is <code>\"scale\"</code>, the object MUST have the property <code>\"scale\"</code>, representing the scaling factor. It MUST be an array of numbers, with the number of elements equal to the number of axes in the coordinate system. If the type is <code>\"translate\"</code>, the object MUST have the property <code>\"translate\"</code>, representing the translation vector. It MUST be an array of numbers, with the number of elements equal to the number of axes in the coordinate system. If the type is <code>\"identity\"</code>, the object MUST NOT have any other properties.</li> <li><code>\"transformationMatrix\"</code>: Representing the transformation matrix from the coordinate system of the image to the coordinate system of the MicroJSON object. It MUST be an array of arrays of numbers, with the number of rows equal to the number of axes in the coordinate system, and the number of columns equal to the number of axes in the image coordinate system. The transformation matrix MUST be invertible.</li> </ul>"},{"location":"tiling/#axis-object","title":"Axis Object","text":"<p>Together with the other axes in the axes array, an axis object represents the coordinate system of the MicroJSON object (2D-5D) It MUST have the following properties:</p> <ul> <li><code>\"name\"</code>: Representing the name of the axis. It MUST be a string. It may contain the following properties:</li> <li><code>\"unit\"</code>: Representing the units of the corresponding axis of the geometries in the MicroJSON object. It MUST be an array with the elements having any of the following values: <code>[\u201cangstrom\", \"attometer\", \"centimeter\", \"decimeter\", \"exameter\", \"femtometer\", \"foot\", \"gigameter\", \"hectometer\", \"inch\", \"kilometer\", \"megameter\", \"meter\", \"micrometer\", \"mile\", \"millimeter\", \"nanometer\", \"parsec\", \"petameter\", \"picometer\", \"terameter\", \"yard\", \"yoctometer\", \"yottameter\", \"zeptometer\", \"zettameter\u201c]</code></li> <li><code>\"description\"</code>: A string describing the axis.</li> </ul>"},{"location":"tiling/#pydantic-model-for-tilejson-for-microjson","title":"Pydantic Model for TileJSON for MicroJSON","text":""},{"location":"tiling/#tilejson","title":"TileJSON","text":"<p>               Bases: <code>RootModel</code></p> <p>The root object of a TileJSON file.</p> Source code in <code>src/microjson/tilemodel.py</code> <pre><code>class TileJSON(RootModel):\n    \"\"\" The root object of a TileJSON file.\"\"\"\n    root: TileModel\n</code></pre>"},{"location":"tiling/#tilemodel","title":"TileModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>A TileJSON object.</p> <p>Parameters:</p> Name Type Description Default <code>tilejson</code> <code>str</code> <p>The TileJSON version.</p> required <code>tiles</code> <code>List[Union[Path, AnyUrl]]</code> <p>The list of tile URLs.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the tileset.</p> required <code>description</code> <code>Optional[str]</code> <p>The description of the tileset.</p> required <code>version</code> <code>Optional[str]</code> <p>The version of the tileset.</p> required <code>attribution</code> <code>Optional[str]</code> <p>The attribution of the tileset.</p> required <code>template</code> <code>Optional[str]</code> <p>The template of the tileset.</p> required <code>legend</code> <code>Optional[str]</code> <p>The legend of the tileset.</p> required <code>scheme</code> <code>Optional[str]</code> <p>The scheme of the tileset.</p> required <code>grids</code> <code>Optional[Union[Path, AnyUrl]]</code> <p>The grids of the tileset.</p> required <code>data</code> <code>Optional[Union[Path, AnyUrl]]</code> <p>The data of the tileset.</p> required <code>minzoom</code> <code>Optional[int]</code> <p>The minimum zoom level of the tileset.</p> required <code>maxzoom</code> <code>Optional[int]</code> <p>The maximum zoom level of the tileset.</p> required <code>bounds</code> <code>Optional[conlist(float, min_length=4, max_length=10)]</code> <p>The bounds of the tileset.</p> required <code>center</code> <code>Optional[conlist(float, min_length=3, max_length=6)]</code> <p>The center of the tileset.</p> required <code>fillzoom</code> <code>Optional[int]</code> <p>The fill zoom level of the tileset.</p> required <code>vector_layers</code> <code>List[TileLayer]</code> <p>The vector layers of the tileset.</p> required Source code in <code>src/microjson/tilemodel.py</code> <pre><code>class TileModel(BaseModel):\n    \"\"\" A TileJSON object.\n\n    Args:\n        tilejson (str): The TileJSON version.\n        tiles (List[Union[Path, AnyUrl]]): The list of tile URLs.\n        name (Optional[str]): The name of the tileset.\n        description (Optional[str]): The description of the tileset.\n        version (Optional[str]): The version of the tileset.\n        attribution (Optional[str]): The attribution of the tileset.\n        template (Optional[str]): The template of the tileset.\n        legend (Optional[str]): The legend of the tileset.\n        scheme (Optional[str]): The scheme of the tileset.\n        grids (Optional[Union[Path, AnyUrl]]): The grids of the tileset.\n        data (Optional[Union[Path, AnyUrl]]): The data of the tileset.\n        minzoom (Optional[int]): The minimum zoom level of the tileset.\n        maxzoom (Optional[int]): The maximum zoom level of the tileset.\n        bounds (Optional[conlist(float, min_length=4, max_length=10)]):\n            The bounds of the tileset.\n        center (Optional[conlist(float, min_length=3, max_length=6)]):\n            The center of the tileset.\n        fillzoom (Optional[int]): The fill zoom level of the tileset.\n        vector_layers (List[TileLayer]): The vector layers of the tileset.\n\n    \"\"\"\n\n    tilejson: str\n    tiles: List[Union[Path, AnyUrl]]\n    name: Optional[str] = None\n    description: Optional[str] = None\n    version: Optional[str] = None\n    attribution: Optional[str] = None\n    template: Optional[str] = None\n    legend: Optional[str] = None\n    scheme: Optional[str] = None\n    grids: Optional[Union[Path, AnyUrl]] = None\n    data: Optional[Union[Path, AnyUrl]] = None\n    minzoom: Optional[int] = 0\n    maxzoom: Optional[int] = 22\n    bounds: Optional[conlist(  # type: ignore\n        float,\n        min_length=4,\n        max_length=10)] = None\n    center: Optional[conlist(  # type: ignore\n        float,\n        min_length=3,\n        max_length=6)] = None\n    fillzoom: Optional[int] = None\n    vector_layers: List[TileLayer]\n    multiscale: Optional[Multiscale] = None\n    scale_factor: Optional[float] = None\n</code></pre>"},{"location":"tiling/#tilelayer","title":"TileLayer","text":"<p>               Bases: <code>BaseModel</code></p> <p>A vector layer in a TileJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The unique identifier for the layer.</p> required <code>fields</code> <code>Union[None, Dict[str, str]]</code> <p>The fields in the layer.</p> required <code>minzoom</code> <code>Optional[int]</code> <p>The minimum zoom level for the layer.</p> required <code>maxzoom</code> <code>Optional[int]</code> <p>The maximum zoom level for the layer.</p> required <code>description</code> <code>Optional[str]</code> <p>A description of the layer.</p> required <code>fieldranges</code> <code>Optional[Dict[str, List[Union[int, float, str]]]]</code> <p>The ranges of the fields.</p> required <code>fieldenums</code> <code>Optional[Dict[str, List[str]]]</code> <p>The enums of the fields.</p> required <code>fielddescriptions</code> <code>Optional[Dict[str, str]]</code> <p>The descriptions of the fields.</p> required Source code in <code>src/microjson/tilemodel.py</code> <pre><code>class TileLayer(BaseModel):\n    \"\"\" A vector layer in a TileJSON file.\n\n    Args:\n        id (str): The unique identifier for the layer.\n        fields (Union[None, Dict[str, str]]): The fields in the layer.\n        minzoom (Optional[int]): The minimum zoom level for the layer.\n        maxzoom (Optional[int]): The maximum zoom level for the layer.\n        description (Optional[str]): A description of the layer.\n        fieldranges (Optional[Dict[str, List[Union[int, float, str]]]]):\n            The ranges of the fields.\n        fieldenums (Optional[Dict[str, List[str]]]):\n            The enums of the fields.\n        fielddescriptions (Optional[Dict[str, str]]):\n            The descriptions of the fields.\n    \"\"\"\n    id: str\n    fields: Union[None, Dict[str, str]] = None\n    minzoom: Optional[int] = 0\n    maxzoom: Optional[int] = 22\n    description: Optional[str] = None\n    fieldranges: Optional[Dict[str, List[Union[int, float, str]]]] = None\n    fieldenums: Optional[Dict[str, List[str]]] = None\n    fielddescriptions: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"tiling/#general-tiling-requirements","title":"General tiling requirements","text":"<p>This specification is designed to be compatible with the Vector Tile Specification and the TileJSON 3.0.0 specification. The Vector Tile Specification specifically requires vector tiles to be agnostic of the global coordinate system, and thus followingly each tile has a relative coordinate system, which instead is defined in the TileJSON. Our ambitions in general are to follow the same principles.</p> <p>One difference is that we here recommend that the file ending for binary tiles is <code>.pbf</code> instead of <code>.mvt</code> to avoid confusion with the Mapbox Vector Tile format. The binary tiles should be encoded in the Protobuf format as defined in the Vector Tile Specification.</p>"},{"location":"tiling/#microjson2vt","title":"MicroJSON2vt","text":"<p>The MicroJSON2vt module is a helper module that can be used to convert MicroJSON objects to vector tiles. It is designed to be used in conjunction with the TileJSON for MicroJSON specification, and can be used to generate vector tiles from MicroJSON objects. The module is designed to be compatible with the Vector Tile Specification, and can be used to generate vector tiles in the intermediate vector tile JSON-format, which then, using <code>vt2pbf</code> may be transformed into protobuf. The module is included in the <code>microjson</code> package, and its wrapper function can be imported using the following code:</p> <pre><code>from microjson import microjson2vt\n</code></pre> <p>The module: </p> <p>MicroJsonVt class, which is the main class for generating vector tiles from MicroJSON data</p> Source code in <code>src/microjson/microjson2vt/microjson2vt.py</code> <pre><code>class MicroJsonVt:\n    \"\"\"\n    MicroJsonVt class, which is the main class for generating vector tiles\n    from MicroJSON data\n    \"\"\"\n    def __init__(self, data, options, log_level=logging.INFO):\n        \"\"\"\n        Constructor for MicroJsonVt class\n\n        Args:\n            data (dict): The data to be converted to vector tiles\n            options (dict): The options to be used for generating vector tiles\n            log_level (int): The logging level to be used\n        \"\"\"\n        logging.basicConfig(\n            level=log_level, format='%(asctime)s %(levelname)s %(message)s')\n        options = self.options = extend(get_default_options(), options)\n\n        # Validate and resolve tolerance_function\n        tolerance_setting = options.get('tolerance_function')\n        if isinstance(tolerance_setting, str):\n            if tolerance_setting in AVAILABLE_TOLERANCE_FUNCTIONS:\n                options['tolerance_function'] = AVAILABLE_TOLERANCE_FUNCTIONS[tolerance_setting]\n            else:\n                raise ValueError(\n                    f\"Invalid tolerance function key: '{tolerance_setting}'. \"\n                    f\"Available keys: {list(AVAILABLE_TOLERANCE_FUNCTIONS.keys())}\"\n                )\n        elif not callable(tolerance_setting):\n            raise TypeError(\n                \"Option 'tolerance_function' must be a callable function or a valid string key.\"\n            )\n        # If it's already callable, we use it directly.\n\n        logging.debug('preprocess data start')\n\n        if options.get('maxZoom') &lt; 0 or options.get('maxZoom') &gt; 24:\n            raise Exception('maxZoom should be in the 0-24 range')\n        if options.get(\n            'promoteId', None) is not None and options.get(\n                'generateId', False):\n            raise Exception(\n                'promoteId and generateId cannot be used together.')\n\n        # projects and adds simplification info\n        # Create a new instance of a CartesianProjector\n\n        features = convert(data, options)\n\n        # Create a separate geometry for each zoom level\n        for z in range(options.get('maxZoom') + 1):\n            for feature in features:\n                feature[f'geometry_z{z}'] = feature['geometry'].copy()\n\n        tolerance_func = options['tolerance_function'] # Resolved above\n\n        # Simplify features for each zoom level\n        for z in range(options.get('maxZoom') + 1):\n            # Calculate tolerance using the provided or default function\n            tolerance = tolerance_func(z, options)\n            for feature in features:\n                geometry_key = f'geometry_z{z}'\n                # check feature type only simplify Polygon\n                if feature['type'] == 'Polygon':\n                    for iring in range(len(feature[geometry_key])):\n                        ring = feature[geometry_key][iring]\n                        # Convert geom to list of [x, y] pairs\n                        coords = [[ring[i], ring[i + 1]] for i in range(\n                            0, len(ring), 3)]\n                        scoords = simplify(coords, tolerance)\n                        # Check that it has at least 4 pairs of coordinates\n                        if len(scoords) &lt; 4:\n                            # If not, use the original coordinates\n                            feature[geometry_key][iring] = ring\n                        else:\n                            # flatten the simplified coords\n                            simplified_ring = []\n                            for i in range(len(scoords)):\n                                simplified_ring.append(scoords[i][0])\n                                simplified_ring.append(scoords[i][1])\n                                simplified_ring.append(0)\n                            feature[geometry_key][iring] = simplified_ring\n\n        # tiles and tile_coords are part of the public API\n        self.tiles = {}\n        self.tile_coords = []\n\n        self.stats = {}\n        self.total = 0\n\n        # wraps features (ie extreme west and extreme east)\n        # features = wrap(features, options)\n\n        # start slicing from the top tile down\n        if len(features) &gt; 0:\n            self.split_tile(features, 0, 0, 0)\n\n    # splits features from a parent tile to sub-tiles.\n    # z, x, and y are the coordinates of the parent tile\n    # cz, cx, and cy are the coordinates of the target tile\n    #\n    # If no target tile is specified, splitting stops when we reach the maximum\n    # zoom or the number of points is low as specified in the options.\n\n    def split_tile(self, features, z, x, y, cz=None, cx=None, cy=None):\n        \"\"\"\n        Splits features from a parent tile to sub-tiles.\n\n        Args:\n            features (list): The features to be split\n            z (int): The zoom level of the parent tile\n            x (int): The x coordinate of the parent tile\n            y (int): The y coordinate of the parent tile\n            cz (int): The zoom level of the target tile\n            cx (int): The x coordinate of the target tile\n            cy (int): The y coordinate of the target tile\n        \"\"\"\n        stack = [features, z, x, y]\n        options = self.options\n        # avoid recursion by using a processing queue\n        while len(stack) &gt; 0:\n            y = stack.pop()\n            x = stack.pop()\n            z = stack.pop()\n            features = stack.pop()\n\n            z2 = 1 &lt;&lt; z\n            id_ = to_Id(z, x, y)\n            tile = self.tiles.get(id_, None)\n\n            if tile is None:\n                # Use simplified geometries for this zoom level\n\n                simplified_features = [\n                    {\n                        **feature,\n                        \"geometry\": feature[f'geometry_z{z}']\n                    }\n                    for feature in features\n                ]\n\n                self.tiles[id_] = create_tile(features, z, x, y, options)\n                tile = self.tiles[id_]\n                self.tile_coords.append({'z': z, 'x': x, 'y': y})\n\n                key = f'z{z}'\n                self.stats[key] = self.stats.get(key, 0) + 1\n                self.total += 1\n\n                self.tiles[id_] = create_tile(\n                    simplified_features, z, x, y, options)\n                tile = self.tiles[id_]\n                self.tile_coords.append({'z': z, 'x': x, 'y': y})\n\n                self.stats[f'z{z}'] = self.stats.get(f'z{z}', 0) + 1\n                self.total += 1\n\n            # save reference to original geometry in tile so that we can drill\n            # down later if we stop now\n            tile['source'] = features\n\n            # if it's the first-pass tiling\n            if cz is None:\n                # stop tiling if we reached max zoom, or if the tile is too\n                # simple\n                if z == options.get(\n                    'indexMaxZoom') or tile.get(\n                        'numPoints') &lt;= options.get('indexMaxPoints'):\n                    continue  # if a drilldown to a specific tile\n            elif z == options.get('maxZoom') or z == cz:\n                # stop tiling if we reached base zoom or our target tile zoom\n                continue\n            elif cz is not None:\n                # stop tiling if it's not an ancestor of the target tile\n                zoomSteps = cz - z\n                if x != (cx &gt;&gt; zoomSteps) or y != (cy &gt;&gt; zoomSteps):\n                    continue\n\n            # if we slice further down, no need to keep source geometry\n            tile['source'] = None\n\n            if not features or len(features) == 0:\n                continue\n\n            logging.debug('clipping start')\n\n            # values we'll use for clipping\n            k1 = 0.5 * options.get('buffer') / options.get('extent')\n            k2 = 0.5 - k1\n            k3 = 0.5 + k1\n            k4 = 1 + k1\n\n            tl = None\n            bl = None\n            tr = None\n            br = None\n\n            left = clip(features, z2, x - k1, x + k3, 0,\n                        tile['minX'], tile['maxX'], options, z+1)\n            right = clip(features, z2, x + k2, x + k4, 0,\n                         tile['minX'], tile['maxX'], options, z+1)\n            features = None\n\n            if left is not None:\n                tl = clip(left, z2, y - k1, y + k3, 1,\n                          tile['minY'], tile['maxY'], options, z+1)\n                bl = clip(left, z2, y + k2, y + k4, 1,\n                          tile['minY'], tile['maxY'], options, z+1)\n                left = None\n\n            if right is not None:\n                tr = clip(right, z2, y - k1, y + k3, 1,\n                          tile['minY'], tile['maxY'], options, z+1)\n                br = clip(right, z2, y + k2, y + k4, 1,\n                          tile['minY'], tile['maxY'], options, z+1)\n                right = None\n\n            logging.debug('clipping ended')\n\n            stack.append(tl if tl is not None else [])\n            stack.append(z + 1)\n            stack.append(x * 2)\n            stack.append(y * 2)\n\n            stack.append(bl if bl is not None else [])\n            stack.append(z + 1)\n            stack.append(x * 2)\n            stack.append(y * 2 + 1)\n\n            stack.append(tr if tr is not None else [])\n            stack.append(z + 1)\n            stack.append(x * 2 + 1)\n            stack.append(y * 2)\n\n            stack.append(br if br is not None else [])\n            stack.append(z + 1)\n            stack.append(x * 2 + 1)\n            stack.append(y * 2 + 1)\n\n    def get_tile(self, z, x, y):\n        z = int(z)\n        x = int(x)\n        y = int(y)\n\n        options = self.options\n        extent = options.get('extent')\n\n        if z &lt; 0 or z &gt; 24:\n            return None\n\n        z2 = 1 &lt;&lt; z\n        x = (x + z2) &amp; (z2 - 1)  # wrap tile x coordinate\n\n        id_ = to_Id(z, x, y)\n        current_tile = self.tiles.get(id_, None)\n        if current_tile is not None:\n            return transform_tile(self.tiles[id_], extent)\n\n        logging.debug(f'drilling down to z{z}-{x}-{y}')\n\n        z0 = z\n        x0 = x\n        y0 = y\n        parent = None\n\n        while parent is None and z0 &gt; 0:\n            z0 -= 1\n            x0 = x0 &gt;&gt; 1\n            y0 = y0 &gt;&gt; 1\n            parent = self.tiles.get(to_Id(z0, x0, y0), None)\n\n        if parent is None or parent.get('source', None) is None:\n            return None\n\n        # if we found a parent tile containing the original geometry, we can\n        # drill down from it\n        logging.debug(f'found parent tile z{z0}-{x0}-{y0}')\n        logging.debug('drilling down start')\n\n        self.split_tile(parent.get('source'), z0, x0, y0, z, x, y)\n\n        logging.debug('drilling down end')\n\n        transformed = transform_tile(\n            self.tiles[id_], extent) if self.tiles.get(\n                id_, None) is not None else None\n        return transformed\n</code></pre>"},{"location":"tiling/#microjson.microjson2vt.microjson2vt.MicroJsonVt.__init__","title":"<code>__init__(data, options, log_level=logging.INFO)</code>","text":"<p>Constructor for MicroJsonVt class</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to be converted to vector tiles</p> required <code>options</code> <code>dict</code> <p>The options to be used for generating vector tiles</p> required <code>log_level</code> <code>int</code> <p>The logging level to be used</p> <code>INFO</code> Source code in <code>src/microjson/microjson2vt/microjson2vt.py</code> <pre><code>def __init__(self, data, options, log_level=logging.INFO):\n    \"\"\"\n    Constructor for MicroJsonVt class\n\n    Args:\n        data (dict): The data to be converted to vector tiles\n        options (dict): The options to be used for generating vector tiles\n        log_level (int): The logging level to be used\n    \"\"\"\n    logging.basicConfig(\n        level=log_level, format='%(asctime)s %(levelname)s %(message)s')\n    options = self.options = extend(get_default_options(), options)\n\n    # Validate and resolve tolerance_function\n    tolerance_setting = options.get('tolerance_function')\n    if isinstance(tolerance_setting, str):\n        if tolerance_setting in AVAILABLE_TOLERANCE_FUNCTIONS:\n            options['tolerance_function'] = AVAILABLE_TOLERANCE_FUNCTIONS[tolerance_setting]\n        else:\n            raise ValueError(\n                f\"Invalid tolerance function key: '{tolerance_setting}'. \"\n                f\"Available keys: {list(AVAILABLE_TOLERANCE_FUNCTIONS.keys())}\"\n            )\n    elif not callable(tolerance_setting):\n        raise TypeError(\n            \"Option 'tolerance_function' must be a callable function or a valid string key.\"\n        )\n    # If it's already callable, we use it directly.\n\n    logging.debug('preprocess data start')\n\n    if options.get('maxZoom') &lt; 0 or options.get('maxZoom') &gt; 24:\n        raise Exception('maxZoom should be in the 0-24 range')\n    if options.get(\n        'promoteId', None) is not None and options.get(\n            'generateId', False):\n        raise Exception(\n            'promoteId and generateId cannot be used together.')\n\n    # projects and adds simplification info\n    # Create a new instance of a CartesianProjector\n\n    features = convert(data, options)\n\n    # Create a separate geometry for each zoom level\n    for z in range(options.get('maxZoom') + 1):\n        for feature in features:\n            feature[f'geometry_z{z}'] = feature['geometry'].copy()\n\n    tolerance_func = options['tolerance_function'] # Resolved above\n\n    # Simplify features for each zoom level\n    for z in range(options.get('maxZoom') + 1):\n        # Calculate tolerance using the provided or default function\n        tolerance = tolerance_func(z, options)\n        for feature in features:\n            geometry_key = f'geometry_z{z}'\n            # check feature type only simplify Polygon\n            if feature['type'] == 'Polygon':\n                for iring in range(len(feature[geometry_key])):\n                    ring = feature[geometry_key][iring]\n                    # Convert geom to list of [x, y] pairs\n                    coords = [[ring[i], ring[i + 1]] for i in range(\n                        0, len(ring), 3)]\n                    scoords = simplify(coords, tolerance)\n                    # Check that it has at least 4 pairs of coordinates\n                    if len(scoords) &lt; 4:\n                        # If not, use the original coordinates\n                        feature[geometry_key][iring] = ring\n                    else:\n                        # flatten the simplified coords\n                        simplified_ring = []\n                        for i in range(len(scoords)):\n                            simplified_ring.append(scoords[i][0])\n                            simplified_ring.append(scoords[i][1])\n                            simplified_ring.append(0)\n                        feature[geometry_key][iring] = simplified_ring\n\n    # tiles and tile_coords are part of the public API\n    self.tiles = {}\n    self.tile_coords = []\n\n    self.stats = {}\n    self.total = 0\n\n    # wraps features (ie extreme west and extreme east)\n    # features = wrap(features, options)\n\n    # start slicing from the top tile down\n    if len(features) &gt; 0:\n        self.split_tile(features, 0, 0, 0)\n</code></pre>"},{"location":"tiling/#microjson.microjson2vt.microjson2vt.MicroJsonVt.split_tile","title":"<code>split_tile(features, z, x, y, cz=None, cx=None, cy=None)</code>","text":"<p>Splits features from a parent tile to sub-tiles.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>list</code> <p>The features to be split</p> required <code>z</code> <code>int</code> <p>The zoom level of the parent tile</p> required <code>x</code> <code>int</code> <p>The x coordinate of the parent tile</p> required <code>y</code> <code>int</code> <p>The y coordinate of the parent tile</p> required <code>cz</code> <code>int</code> <p>The zoom level of the target tile</p> <code>None</code> <code>cx</code> <code>int</code> <p>The x coordinate of the target tile</p> <code>None</code> <code>cy</code> <code>int</code> <p>The y coordinate of the target tile</p> <code>None</code> Source code in <code>src/microjson/microjson2vt/microjson2vt.py</code> <pre><code>def split_tile(self, features, z, x, y, cz=None, cx=None, cy=None):\n    \"\"\"\n    Splits features from a parent tile to sub-tiles.\n\n    Args:\n        features (list): The features to be split\n        z (int): The zoom level of the parent tile\n        x (int): The x coordinate of the parent tile\n        y (int): The y coordinate of the parent tile\n        cz (int): The zoom level of the target tile\n        cx (int): The x coordinate of the target tile\n        cy (int): The y coordinate of the target tile\n    \"\"\"\n    stack = [features, z, x, y]\n    options = self.options\n    # avoid recursion by using a processing queue\n    while len(stack) &gt; 0:\n        y = stack.pop()\n        x = stack.pop()\n        z = stack.pop()\n        features = stack.pop()\n\n        z2 = 1 &lt;&lt; z\n        id_ = to_Id(z, x, y)\n        tile = self.tiles.get(id_, None)\n\n        if tile is None:\n            # Use simplified geometries for this zoom level\n\n            simplified_features = [\n                {\n                    **feature,\n                    \"geometry\": feature[f'geometry_z{z}']\n                }\n                for feature in features\n            ]\n\n            self.tiles[id_] = create_tile(features, z, x, y, options)\n            tile = self.tiles[id_]\n            self.tile_coords.append({'z': z, 'x': x, 'y': y})\n\n            key = f'z{z}'\n            self.stats[key] = self.stats.get(key, 0) + 1\n            self.total += 1\n\n            self.tiles[id_] = create_tile(\n                simplified_features, z, x, y, options)\n            tile = self.tiles[id_]\n            self.tile_coords.append({'z': z, 'x': x, 'y': y})\n\n            self.stats[f'z{z}'] = self.stats.get(f'z{z}', 0) + 1\n            self.total += 1\n\n        # save reference to original geometry in tile so that we can drill\n        # down later if we stop now\n        tile['source'] = features\n\n        # if it's the first-pass tiling\n        if cz is None:\n            # stop tiling if we reached max zoom, or if the tile is too\n            # simple\n            if z == options.get(\n                'indexMaxZoom') or tile.get(\n                    'numPoints') &lt;= options.get('indexMaxPoints'):\n                continue  # if a drilldown to a specific tile\n        elif z == options.get('maxZoom') or z == cz:\n            # stop tiling if we reached base zoom or our target tile zoom\n            continue\n        elif cz is not None:\n            # stop tiling if it's not an ancestor of the target tile\n            zoomSteps = cz - z\n            if x != (cx &gt;&gt; zoomSteps) or y != (cy &gt;&gt; zoomSteps):\n                continue\n\n        # if we slice further down, no need to keep source geometry\n        tile['source'] = None\n\n        if not features or len(features) == 0:\n            continue\n\n        logging.debug('clipping start')\n\n        # values we'll use for clipping\n        k1 = 0.5 * options.get('buffer') / options.get('extent')\n        k2 = 0.5 - k1\n        k3 = 0.5 + k1\n        k4 = 1 + k1\n\n        tl = None\n        bl = None\n        tr = None\n        br = None\n\n        left = clip(features, z2, x - k1, x + k3, 0,\n                    tile['minX'], tile['maxX'], options, z+1)\n        right = clip(features, z2, x + k2, x + k4, 0,\n                     tile['minX'], tile['maxX'], options, z+1)\n        features = None\n\n        if left is not None:\n            tl = clip(left, z2, y - k1, y + k3, 1,\n                      tile['minY'], tile['maxY'], options, z+1)\n            bl = clip(left, z2, y + k2, y + k4, 1,\n                      tile['minY'], tile['maxY'], options, z+1)\n            left = None\n\n        if right is not None:\n            tr = clip(right, z2, y - k1, y + k3, 1,\n                      tile['minY'], tile['maxY'], options, z+1)\n            br = clip(right, z2, y + k2, y + k4, 1,\n                      tile['minY'], tile['maxY'], options, z+1)\n            right = None\n\n        logging.debug('clipping ended')\n\n        stack.append(tl if tl is not None else [])\n        stack.append(z + 1)\n        stack.append(x * 2)\n        stack.append(y * 2)\n\n        stack.append(bl if bl is not None else [])\n        stack.append(z + 1)\n        stack.append(x * 2)\n        stack.append(y * 2 + 1)\n\n        stack.append(tr if tr is not None else [])\n        stack.append(z + 1)\n        stack.append(x * 2 + 1)\n        stack.append(y * 2)\n\n        stack.append(br if br is not None else [])\n        stack.append(z + 1)\n        stack.append(x * 2 + 1)\n        stack.append(y * 2 + 1)\n</code></pre>"},{"location":"tiling/#tilewriter-module","title":"TileWriter module","text":"<p>The TileWriter module is a helper module that can be used to generate binary tiles from a large MicroJSON file, my utilizing both microjson2vt and vt2pbf. </p> <p>An example of how to use the TileWriter module is located in the <code>src/microjson/examples/tiling.py</code> file of the repository. The example demonstrates how to generate binary tiles from a large MicroJSON file.</p>"},{"location":"tiling/#microjson.tilewriter.TileWriter","title":"<code>TileWriter</code>","text":"<p>               Bases: <code>TileHandler</code></p> Source code in <code>src/microjson/tilewriter.py</code> <pre><code>class TileWriter (TileHandler):\n\n    def microjson2tiles(self,\n                        microjson_data_path: Union[str, Path],\n                        validate: bool = False,\n                        tolerance_key: str = \"default\"\n                        ) -&gt; List[str]:\n        \"\"\"\n        Generate tiles in form of JSON or PBF files from MicroJSON data.\n\n        Args:\n            microjson_data_path (Union[str, Path]): Path to the\n            MicroJSON data file\n            validate (bool): Flag to indicate whether to validate\n            the MicroJSON data\n\n        Returns:\n            List[str]: List of paths to the generated tiles\n        \"\"\"\n        def save_tile(tile_data, z, x, y, tiles_path_template):\n            \"\"\"\n            Save a single tile to a file based on the template path.\n\n            Args:\n                tile_data: The tile data to save\n                z: The zoom level of the tile\n                x: The x coordinate of the tile\n                y: The y coordinate of the tile\n                tiles_path_template: The template path for the tiles\n\n            Returns:\n                str: The path to the saved tile\n            \"\"\"\n            # Format the path template with actual tile coordinates\n            tile_path = str(tiles_path_template).format(z=z, x=x, y=y)\n            os.makedirs(os.path.dirname(tile_path), exist_ok=True)\n\n            # Save the tile data (this assumes tile_data is already in the\n            # correct format, e.g., PBF or JSON)\n            if tile_path.endswith('.parquet'):\n                tile_data.to_parquet(tile_path)\n            else:\n                with open(\n                    tile_path,\n                    'wb' if tile_path.endswith('.pbf') else 'w'\n                ) as f:\n                    f.write(tile_data)\n\n            # return the path to the saved tile\n            return tile_path\n\n        def convert_id_to_int(data) -&gt; int | dict | list:\n            \"\"\"\n            Convert all id fields in the data to integers\n\n            Args:\n                data: The data to convert\n\n            Returns:\n                dict: The data with all id fields converted to integers\n            \"\"\"\n\n            # check if data is a list\n            if isinstance(data, list):\n                for item in data:\n                    convert_id_to_int(item)\n                return data\n            # check if data is a dict\n            elif isinstance(data, dict):\n                for key, value in data.items():\n                    if key == 'id':\n                        if value is None:\n                            data[key] = self.id_counter\n                            self.id_counter += 1\n                        else:\n                            data[key] = int(value)\n                        while data[key] in self.id_set:\n                            self.id_counter += 1\n                            data[key] = self.id_counter\n                        self.id_set.add(data[key])\n                    if isinstance(value, dict):\n                        convert_id_to_int(value)\n                    if isinstance(value, list):\n                        for item in value:\n                            convert_id_to_int(item)\n                return data\n            else:\n                return int(data)\n\n        # Load the MicroJSON data\n        with open(microjson_data_path, 'r') as file:\n            microjson_data = json.load(file)\n\n        # Validate the MicroJSON data\n        if validate:\n            try:\n                MicroJSON.model_validate(microjson_data)\n            except ValidationError as e:\n                logger.error(f\"MicroJSON data validation failed: {e}\")\n                return []\n\n        # TODO currently only supports one tile layer\n        # calculate maxzoom and minzoom from layer and global tilejson\n\n        maxzoom = min(self.tile_json.maxzoom,\n                      self.tile_json.vector_layers[0].maxzoom)  # type: ignore\n        minzoom = max(self.tile_json.minzoom,\n                      self.tile_json.vector_layers[0].minzoom)  # type: ignore\n\n        # Options for geojson2vt from TileJSON\n        options = {\n            'maxZoom': maxzoom,  # max zoom in the final tileset\n            'indexMaxZoom': self.tile_json.maxzoom,  # tile index max zoom\n            'indexMaxPoints': 0,  # max number of points per tile, 0 if none\n            'bounds': self.tile_json.bounds,\n            'tolerance_function': tolerance_key # Pass the string key\n        }\n\n        # Convert GeoJSON to intermediate vector tiles\n        tile_index = microjson2vt(microjson_data, options)\n\n        # Placeholder for the tile paths\n        generated_tiles = []\n\n        # get tilepath from tilejson self.tile_json.tiles\n        # extract the folder from the filepath\n\n        for tileno in tile_index.tiles:\n            atile = tile_index.tiles[tileno]\n            x, y, z = atile[\"x\"], atile[\"y\"], atile[\"z\"]\n            # if z is less than minzoom, or greater than maxzoom, skip the tile\n            if z &lt; minzoom or z &gt; maxzoom:\n                continue\n            tile_data = tile_index.get_tile(z, x, y)\n\n            for item in tile_data['features']:\n                if 'id' in item:\n                    item['id'] = int(item['id'])\n\n            # add name to the tile_data\n            tile_data[\"name\"] = \"tile\"\n\n            # print('tile_data before encoding')\n            # print(tile_data.keys())\n            # print(json.dumps(tile_data['features']))\n\n            # convert this dictionary to a geodataframe using gpd.GeoDataFrame.from_features\n            # tmp = gpd.GeoDataFrame.from_features(tile_data['features'])\n            # print(tmp)\n\n            # print('-------------------------')\n            # print('-------------------------')\n\n            # print('testing geopandas!')\n            # gdf = gpd.GeoDataFrame(tile_data)\n            # print(gdf)\n\n            # print('self.pbf', self.pbf)\n            # print('self.parquet', self.parquet)\n\n            if self.pbf:\n                # Using vt2pbf to encode tile data to PBF\n                encoded_data = vt2pbf(tile_data)\n            elif self.parquet:\n                # encoded_data = pd.DataFrame(tile_data)\n                encoded_data = gpd.GeoDataFrame(tile_data)\n\n                # drop metadata columns\n                encoded_data['new_geometry'] = encoded_data['features'].apply(lambda x: x['geometry'])\n                # encoded_data['Label'] = encoded_data['features'].apply(lambda x: x['Label'])\n                encoded_data = encoded_data[['new_geometry']]\n\n            else:\n                encoded_data = json.dumps(tile_data)\n\n            # print('self.tile_json.tiles[0]')\n            # print(self.tile_json.tiles[0])\n\n            # print('type(encoded_data)')\n            # print(type(encoded_data))\n\n            generated_tiles.append(save_tile(\n                encoded_data, z, x, y, self.tile_json.tiles[0]))\n\n        return generated_tiles\n</code></pre>"},{"location":"tiling/#microjson.tilewriter.TileWriter.microjson2tiles","title":"<code>microjson2tiles(microjson_data_path, validate=False, tolerance_key='default')</code>","text":"<p>Generate tiles in form of JSON or PBF files from MicroJSON data.</p> <p>Parameters:</p> Name Type Description Default <code>microjson_data_path</code> <code>Union[str, Path]</code> <p>Path to the</p> required <code>validate</code> <code>bool</code> <p>Flag to indicate whether to validate</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of paths to the generated tiles</p> Source code in <code>src/microjson/tilewriter.py</code> <pre><code>def microjson2tiles(self,\n                    microjson_data_path: Union[str, Path],\n                    validate: bool = False,\n                    tolerance_key: str = \"default\"\n                    ) -&gt; List[str]:\n    \"\"\"\n    Generate tiles in form of JSON or PBF files from MicroJSON data.\n\n    Args:\n        microjson_data_path (Union[str, Path]): Path to the\n        MicroJSON data file\n        validate (bool): Flag to indicate whether to validate\n        the MicroJSON data\n\n    Returns:\n        List[str]: List of paths to the generated tiles\n    \"\"\"\n    def save_tile(tile_data, z, x, y, tiles_path_template):\n        \"\"\"\n        Save a single tile to a file based on the template path.\n\n        Args:\n            tile_data: The tile data to save\n            z: The zoom level of the tile\n            x: The x coordinate of the tile\n            y: The y coordinate of the tile\n            tiles_path_template: The template path for the tiles\n\n        Returns:\n            str: The path to the saved tile\n        \"\"\"\n        # Format the path template with actual tile coordinates\n        tile_path = str(tiles_path_template).format(z=z, x=x, y=y)\n        os.makedirs(os.path.dirname(tile_path), exist_ok=True)\n\n        # Save the tile data (this assumes tile_data is already in the\n        # correct format, e.g., PBF or JSON)\n        if tile_path.endswith('.parquet'):\n            tile_data.to_parquet(tile_path)\n        else:\n            with open(\n                tile_path,\n                'wb' if tile_path.endswith('.pbf') else 'w'\n            ) as f:\n                f.write(tile_data)\n\n        # return the path to the saved tile\n        return tile_path\n\n    def convert_id_to_int(data) -&gt; int | dict | list:\n        \"\"\"\n        Convert all id fields in the data to integers\n\n        Args:\n            data: The data to convert\n\n        Returns:\n            dict: The data with all id fields converted to integers\n        \"\"\"\n\n        # check if data is a list\n        if isinstance(data, list):\n            for item in data:\n                convert_id_to_int(item)\n            return data\n        # check if data is a dict\n        elif isinstance(data, dict):\n            for key, value in data.items():\n                if key == 'id':\n                    if value is None:\n                        data[key] = self.id_counter\n                        self.id_counter += 1\n                    else:\n                        data[key] = int(value)\n                    while data[key] in self.id_set:\n                        self.id_counter += 1\n                        data[key] = self.id_counter\n                    self.id_set.add(data[key])\n                if isinstance(value, dict):\n                    convert_id_to_int(value)\n                if isinstance(value, list):\n                    for item in value:\n                        convert_id_to_int(item)\n            return data\n        else:\n            return int(data)\n\n    # Load the MicroJSON data\n    with open(microjson_data_path, 'r') as file:\n        microjson_data = json.load(file)\n\n    # Validate the MicroJSON data\n    if validate:\n        try:\n            MicroJSON.model_validate(microjson_data)\n        except ValidationError as e:\n            logger.error(f\"MicroJSON data validation failed: {e}\")\n            return []\n\n    # TODO currently only supports one tile layer\n    # calculate maxzoom and minzoom from layer and global tilejson\n\n    maxzoom = min(self.tile_json.maxzoom,\n                  self.tile_json.vector_layers[0].maxzoom)  # type: ignore\n    minzoom = max(self.tile_json.minzoom,\n                  self.tile_json.vector_layers[0].minzoom)  # type: ignore\n\n    # Options for geojson2vt from TileJSON\n    options = {\n        'maxZoom': maxzoom,  # max zoom in the final tileset\n        'indexMaxZoom': self.tile_json.maxzoom,  # tile index max zoom\n        'indexMaxPoints': 0,  # max number of points per tile, 0 if none\n        'bounds': self.tile_json.bounds,\n        'tolerance_function': tolerance_key # Pass the string key\n    }\n\n    # Convert GeoJSON to intermediate vector tiles\n    tile_index = microjson2vt(microjson_data, options)\n\n    # Placeholder for the tile paths\n    generated_tiles = []\n\n    # get tilepath from tilejson self.tile_json.tiles\n    # extract the folder from the filepath\n\n    for tileno in tile_index.tiles:\n        atile = tile_index.tiles[tileno]\n        x, y, z = atile[\"x\"], atile[\"y\"], atile[\"z\"]\n        # if z is less than minzoom, or greater than maxzoom, skip the tile\n        if z &lt; minzoom or z &gt; maxzoom:\n            continue\n        tile_data = tile_index.get_tile(z, x, y)\n\n        for item in tile_data['features']:\n            if 'id' in item:\n                item['id'] = int(item['id'])\n\n        # add name to the tile_data\n        tile_data[\"name\"] = \"tile\"\n\n        # print('tile_data before encoding')\n        # print(tile_data.keys())\n        # print(json.dumps(tile_data['features']))\n\n        # convert this dictionary to a geodataframe using gpd.GeoDataFrame.from_features\n        # tmp = gpd.GeoDataFrame.from_features(tile_data['features'])\n        # print(tmp)\n\n        # print('-------------------------')\n        # print('-------------------------')\n\n        # print('testing geopandas!')\n        # gdf = gpd.GeoDataFrame(tile_data)\n        # print(gdf)\n\n        # print('self.pbf', self.pbf)\n        # print('self.parquet', self.parquet)\n\n        if self.pbf:\n            # Using vt2pbf to encode tile data to PBF\n            encoded_data = vt2pbf(tile_data)\n        elif self.parquet:\n            # encoded_data = pd.DataFrame(tile_data)\n            encoded_data = gpd.GeoDataFrame(tile_data)\n\n            # drop metadata columns\n            encoded_data['new_geometry'] = encoded_data['features'].apply(lambda x: x['geometry'])\n            # encoded_data['Label'] = encoded_data['features'].apply(lambda x: x['Label'])\n            encoded_data = encoded_data[['new_geometry']]\n\n        else:\n            encoded_data = json.dumps(tile_data)\n\n        # print('self.tile_json.tiles[0]')\n        # print(self.tile_json.tiles[0])\n\n        # print('type(encoded_data)')\n        # print(type(encoded_data))\n\n        generated_tiles.append(save_tile(\n            encoded_data, z, x, y, self.tile_json.tiles[0]))\n\n    return generated_tiles\n</code></pre>"},{"location":"tiling/#microjson.tilewriter.extract_fields_ranges_enums","title":"<code>extract_fields_ranges_enums(microjson_file)</code>","text":"<p>Extract field names, ranges, and enums from the provided MicroJSON file. Returns:     tuple: (dict with field names and types,             dict of field ranges,             dict of field enums)</p> Source code in <code>src/microjson/tilewriter.py</code> <pre><code>def extract_fields_ranges_enums(microjson_file: str):\n    \"\"\"\n    Extract field names, ranges, and enums from the provided MicroJSON\n    file.\n    Returns:\n        tuple: (dict with field names and types,\n                dict of field ranges,\n                dict of field enums)\n    \"\"\"\n    import json\n\n    def get_json_type(value):\n        if value is None:\n            # Set to String if None\n            return 'String'\n        if isinstance(value, bool):\n            return 'Boolean'\n        if isinstance(value, (int, float)):\n            return 'Number'\n        if isinstance(value, dict):\n            return 'Object'\n        if isinstance(value, list):\n            return 'Array'\n        return 'String'\n\n    with open(microjson_file, 'r') as file:\n        data = json.load(file)\n\n    field_names: dict[str, str] = {}\n    field_ranges = {}\n    field_enums: dict[str, set[str]] = {}\n\n    for feature in data.get('features', []):\n        props = feature.get('properties', {})\n        for key, val in props.items():\n            if key not in field_names.keys():\n                field_names[key] = get_json_type(val)\n            if isinstance(val, (int, float)):\n                if key not in field_ranges:\n                    field_ranges[key] = [val, val]\n                else:\n                    field_ranges[key][0] = min(field_ranges[key][0], val)\n                    field_ranges[key][1] = max(field_ranges[key][1], val)\n            if isinstance(val, str):\n                if key not in field_enums:\n                    field_enums[key] = set()\n                field_enums[key].add(val)\n\n    return field_names, field_ranges, field_enums\n</code></pre>"},{"location":"tiling/#microjson.tilewriter.getbounds","title":"<code>getbounds(microjson_file, square=False)</code>","text":"<p>Get the max and min bounds for coordinates of the MicroJSON file</p> <p>Parameters:</p> Name Type Description Default <code>microjson_file</code> <code>str</code> <p>Path to the MicroJSON file</p> required <code>square</code> <code>bool</code> <p>Flag to indicate whether to return square bounds</p> <code>False</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of the bounds [minx, miny, maxx, maxy]</p> Source code in <code>src/microjson/tilewriter.py</code> <pre><code>def getbounds(microjson_file: str, square: bool = False) -&gt; List[float]:\n    \"\"\"\n    Get the max and min bounds for coordinates of the MicroJSON file\n\n    Args:\n        microjson_file (str): Path to the MicroJSON file\n        square (bool): Flag to indicate whether to return square bounds\n\n    Returns:\n        List[float]: List of the bounds [minx, miny, maxx, maxy]\n    \"\"\"\n    with open(microjson_file, 'r') as file:\n        data = json.load(file)\n\n    # get the bounds\n    minx = miny = float('inf')\n    maxx = maxy = float('-inf')\n    if 'features' in data:\n        for feature in data['features']:\n            if 'geometry' in feature:\n                if feature['geometry']['type'] == 'Polygon':\n                    for ring in feature['geometry']['coordinates']:\n                        for coord in ring:\n                            minx = min(minx, coord[0])\n                            miny = min(miny, coord[1])\n                            maxx = max(maxx, coord[0])\n                            maxy = max(maxy, coord[1])\n                if feature['geometry']['type'] == 'MultiPolygon':\n                    for polygon in feature['geometry']['coordinates']:\n                        for ring in polygon:\n                            for coord in ring:\n                                minx = min(minx, coord[0])\n                                miny = min(miny, coord[1])\n                                maxx = max(maxx, coord[0])\n                                maxy = max(maxy, coord[1])\n    if square:\n        maxx = max(maxx - minx, maxy - miny) + minx\n        maxy = max(maxx - minx, maxy - miny) + miny\n    return [minx, miny, maxx, maxy]\n</code></pre>"},{"location":"tiling/#tilereader-module","title":"TileReader module","text":"<p>Correspondingly, the TileReader module is a helper module that can be used to read binary tiles and convert them back to MicroJSON objects. </p> <p>An example of how to use the TileReader module is located in the <code>src/microjson/examples/readtiles.py</code> file of the repository. The example demonstrates how to read binary tiles and convert them back to MicroJSON objects.</p>"},{"location":"tiling/#microjson.tilereader.TileReader","title":"<code>TileReader</code>","text":"<p>               Bases: <code>TileHandler</code></p> <p>Class to read tiles and generate MicroJSON data</p> Source code in <code>src/microjson/tilereader.py</code> <pre><code>class TileReader(TileHandler):\n    \"\"\"\n    Class to read tiles and generate MicroJSON data\n    \"\"\"\n\n    def tiles2microjson(self,\n                        zlvl: int = 0) -&gt; dict[str, Any]:\n        \"\"\"\n        Generate MicroJSON data from tiles in form of JSON or PBF files.\n        Get the TileJSON configuration and the PBF flag from the class\n        attributes.\n        Check that zlvl is within the maxzoom and minzoom of the tilejson\n        Get the bounds from the tilejson and use to generate the MicroJSON\n        data, by reading the tiles at the specified zoom level and\n        extracting the geometries from the tiles.\n\n        Args:\n            zlvl (int): The zoom level of the tiles to read\n\n        Returns:\n            dict: The generated MicroJSON data\n        \"\"\"\n\n        # check if zlvl is within the maxzoom and minzoom of the tilejson\n        if (self.tile_json.minzoom is None or\n                zlvl &lt; self.tile_json.minzoom or\n                self.tile_json.maxzoom is None or\n                zlvl &gt; self.tile_json.maxzoom):\n            return {}\n\n        # get the bounds from the tilejson\n        bounds = self.tile_json.bounds\n        if bounds is None:\n            return {}\n\n        minx = float(bounds[0])\n        miny = float(bounds[1])\n        maxx = float(bounds[2])\n        maxy = float(bounds[3])\n        ntiles = 2 ** zlvl\n        xstep = (maxx - minx) / ntiles\n        ystep = (maxy - miny) / ntiles\n        xstarts = [minx + x * xstep for x in range(ntiles)]\n        ystarts = [miny + y * ystep for y in range(ntiles)]\n        xstops = [minx + (x + 1) * xstep for x in range(ntiles)]\n        ystops = [miny + (y + 1) * ystep for y in range(ntiles)]\n\n        # reverse the ystarts and ystops\n        # ystarts = ystarts[::-1]\n        # ystops = ystops[::-1]\n\n        def project(coord, xmin, ymin, xmax, ymax,\n                    extent=4096):\n            return [\n                (coord[0] / extent * (xmax - xmin) + xmin),\n                (coord[1] / extent * (ymax - ymin) + ymin)\n            ]\n\n        # get the tilepath from the tilejson\n        tilepath = str(self.tile_json.tiles[0])\n\n        # initialize the microjson data\n        microjson_data = {\n            \"type\": \"FeatureCollection\",\n            \"features\": []\n        }\n\n        # read the tiles and extract the geometries\n        for x in range(ntiles):\n            for y in range(ntiles):\n                xstart = xstarts[x]\n                xstop = xstops[x]\n                ystart = ystarts[y]\n                ystop = ystops[y]\n                # format path template with tile coordinates\n                tile_file = tilepath.format(z=zlvl, x=x, y=y)\n\n                if not os.path.exists(str(tile_file)):\n                    continue\n\n                with open(\n                        str(tile_file),\n                        'rb' if str(tile_file).endswith('.pbf') else 'r') as f:\n                    tile_data = f.read()\n\n                # decode the tile data\n                if self.pbf:\n                    tile_data = mapbox_vector_tile.decode(\n                        tile_data,\n                        default_options={\n                            \"geojson\": True,\n                            \"y_coord_down\": True})\n                else:\n                    tile_data = json.loads(tile_data)\n\n                # dump to file\n                # filename = f\"tilevt11_{x}_{y}_{zlvl}.json\"\n\n                # with open(filename, \"w\") as f:\n                #    json.dump(tile_data, f)\n\n                tile_data = tile_data['geojsonLayer']\n\n                # extract the geometries\n                if 'features' in tile_data.keys():\n                    for feature in tile_data['features']:\n                        # Transform the coordinates to the global coordinate\n                        # system please note that the coordinates may be in\n                        # up to 5 nested lists transform the coordinates in\n                        # place\n                        if 'geometry' in feature:\n                            geom = feature['geometry']\n                            coord = geom['coordinates']\n                            if 'type' in geom:\n                                if geom['type'] == 'Point':\n                                    geom['coordinates'] = project(\n                                        coord, xstart, ystart, xstop, ystop)\n                                elif geom['type'] == 'LineString':\n                                    geom['coordinates'] = [\n                                        project(coord, xstart, ystart, xstop,\n                                                ystop)\n                                        for coord in geom['coordinates']\n                                    ]\n                                elif geom['type'] == 'Polygon':\n                                    geom['coordinates'] = [\n                                        [\n                                            project(coord, xstart, ystart,\n                                                    xstop, ystop)\n                                            for coord in ring\n                                        ]\n                                        for ring in geom['coordinates']\n                                    ]\n                                elif geom['type'] == 'MultiPolygon':\n                                    geom['coordinates'] = [\n                                        [\n                                            [\n                                                project(coord, xstart, ystart,\n                                                        xstop, ystop)\n                                                for coord in ring\n                                            ]\n                                            for ring in poly\n                                        ]\n                                        for poly in geom['coordinates']\n                                    ]\n                                else:\n                                    continue\n\n                            # add the feature to the microjson data\n                            microjson_data['features'].append(  # type: ignore\n                                feature)\n\n        return microjson_data\n</code></pre>"},{"location":"tiling/#microjson.tilereader.TileReader.tiles2microjson","title":"<code>tiles2microjson(zlvl=0)</code>","text":"<p>Generate MicroJSON data from tiles in form of JSON or PBF files. Get the TileJSON configuration and the PBF flag from the class attributes. Check that zlvl is within the maxzoom and minzoom of the tilejson Get the bounds from the tilejson and use to generate the MicroJSON data, by reading the tiles at the specified zoom level and extracting the geometries from the tiles.</p> <p>Parameters:</p> Name Type Description Default <code>zlvl</code> <code>int</code> <p>The zoom level of the tiles to read</p> <code>0</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>The generated MicroJSON data</p> Source code in <code>src/microjson/tilereader.py</code> <pre><code>def tiles2microjson(self,\n                    zlvl: int = 0) -&gt; dict[str, Any]:\n    \"\"\"\n    Generate MicroJSON data from tiles in form of JSON or PBF files.\n    Get the TileJSON configuration and the PBF flag from the class\n    attributes.\n    Check that zlvl is within the maxzoom and minzoom of the tilejson\n    Get the bounds from the tilejson and use to generate the MicroJSON\n    data, by reading the tiles at the specified zoom level and\n    extracting the geometries from the tiles.\n\n    Args:\n        zlvl (int): The zoom level of the tiles to read\n\n    Returns:\n        dict: The generated MicroJSON data\n    \"\"\"\n\n    # check if zlvl is within the maxzoom and minzoom of the tilejson\n    if (self.tile_json.minzoom is None or\n            zlvl &lt; self.tile_json.minzoom or\n            self.tile_json.maxzoom is None or\n            zlvl &gt; self.tile_json.maxzoom):\n        return {}\n\n    # get the bounds from the tilejson\n    bounds = self.tile_json.bounds\n    if bounds is None:\n        return {}\n\n    minx = float(bounds[0])\n    miny = float(bounds[1])\n    maxx = float(bounds[2])\n    maxy = float(bounds[3])\n    ntiles = 2 ** zlvl\n    xstep = (maxx - minx) / ntiles\n    ystep = (maxy - miny) / ntiles\n    xstarts = [minx + x * xstep for x in range(ntiles)]\n    ystarts = [miny + y * ystep for y in range(ntiles)]\n    xstops = [minx + (x + 1) * xstep for x in range(ntiles)]\n    ystops = [miny + (y + 1) * ystep for y in range(ntiles)]\n\n    # reverse the ystarts and ystops\n    # ystarts = ystarts[::-1]\n    # ystops = ystops[::-1]\n\n    def project(coord, xmin, ymin, xmax, ymax,\n                extent=4096):\n        return [\n            (coord[0] / extent * (xmax - xmin) + xmin),\n            (coord[1] / extent * (ymax - ymin) + ymin)\n        ]\n\n    # get the tilepath from the tilejson\n    tilepath = str(self.tile_json.tiles[0])\n\n    # initialize the microjson data\n    microjson_data = {\n        \"type\": \"FeatureCollection\",\n        \"features\": []\n    }\n\n    # read the tiles and extract the geometries\n    for x in range(ntiles):\n        for y in range(ntiles):\n            xstart = xstarts[x]\n            xstop = xstops[x]\n            ystart = ystarts[y]\n            ystop = ystops[y]\n            # format path template with tile coordinates\n            tile_file = tilepath.format(z=zlvl, x=x, y=y)\n\n            if not os.path.exists(str(tile_file)):\n                continue\n\n            with open(\n                    str(tile_file),\n                    'rb' if str(tile_file).endswith('.pbf') else 'r') as f:\n                tile_data = f.read()\n\n            # decode the tile data\n            if self.pbf:\n                tile_data = mapbox_vector_tile.decode(\n                    tile_data,\n                    default_options={\n                        \"geojson\": True,\n                        \"y_coord_down\": True})\n            else:\n                tile_data = json.loads(tile_data)\n\n            # dump to file\n            # filename = f\"tilevt11_{x}_{y}_{zlvl}.json\"\n\n            # with open(filename, \"w\") as f:\n            #    json.dump(tile_data, f)\n\n            tile_data = tile_data['geojsonLayer']\n\n            # extract the geometries\n            if 'features' in tile_data.keys():\n                for feature in tile_data['features']:\n                    # Transform the coordinates to the global coordinate\n                    # system please note that the coordinates may be in\n                    # up to 5 nested lists transform the coordinates in\n                    # place\n                    if 'geometry' in feature:\n                        geom = feature['geometry']\n                        coord = geom['coordinates']\n                        if 'type' in geom:\n                            if geom['type'] == 'Point':\n                                geom['coordinates'] = project(\n                                    coord, xstart, ystart, xstop, ystop)\n                            elif geom['type'] == 'LineString':\n                                geom['coordinates'] = [\n                                    project(coord, xstart, ystart, xstop,\n                                            ystop)\n                                    for coord in geom['coordinates']\n                                ]\n                            elif geom['type'] == 'Polygon':\n                                geom['coordinates'] = [\n                                    [\n                                        project(coord, xstart, ystart,\n                                                xstop, ystop)\n                                        for coord in ring\n                                    ]\n                                    for ring in geom['coordinates']\n                                ]\n                            elif geom['type'] == 'MultiPolygon':\n                                geom['coordinates'] = [\n                                    [\n                                        [\n                                            project(coord, xstart, ystart,\n                                                    xstop, ystop)\n                                            for coord in ring\n                                        ]\n                                        for ring in poly\n                                    ]\n                                    for poly in geom['coordinates']\n                                ]\n                            else:\n                                continue\n\n                        # add the feature to the microjson data\n                        microjson_data['features'].append(  # type: ignore\n                            feature)\n\n    return microjson_data\n</code></pre>"},{"location":"tiling/#tilejson-for-microjson-example-with-vector-layers","title":"TileJSON for MicroJSON example with Vector Layers","text":"<p>The below example illustrates a TileJSON for a MicroJSON tileset multiple layers of detail. The tileset has a single vector layer, <code>image_layer</code> id of <code>vector_layers</code>, which contains a single vector layer describing images. The <code>fields</code> property of the this layer specifies the attributes of the layer, including the data types of the attributes. The <code>tiles</code> property specifies the URL pattern for accessing the vector tiles, which in this case is a 2D data set (no channels, time or z-axis) with zoom level.</p> <p>This file is located in the <code>examples/tiles</code> directory of the repository, and is named <code>tiled_example.json</code>. It has a corresponding MicroJSON file for each tile, located in the <code>examples/tiles/tiled_example</code> directory of the repository. The MicroJSON files are organized according to the tiling scheme, with the directory structure <code>zlvl/x/y.json</code> where <code>zlvl</code> is the zoom level, <code>x</code> is the x coordinate, and <code>y</code> is the y coordinate. The MicroJSON files contain the MicroJSON objects for the corresponding tiles, and are named according to the tiling scheme. For example, the MicroJSON object for the tile at zoom level 1, tile at (0,1) in the tiling scheme is located at <code>examples/tiles/tiled_example/1/0/1.json</code>. Examples for MicroJSON objects at zoom levels 0, 1, and 2 are provided below.</p> <pre><code>{\n    {\n    \"tilejson\": \"3.0.0\",\n    \"name\": \"2D Data Example\",\n    \"description\": \"A tileset showing 2D data with multiple layers of detail.\",\n    \"version\": \"1.0.0\",\n    \"attribution\": \"&lt;a href='http://example.com'&gt;Example&lt;/a&gt;\",\n    \"tiles\": [\n        \"http://example.com/tiled_example/{zlvl}/{x}/{y}.json\"\n    ],\n    \"minzoom\": 0,\n    \"maxzoom\": 10,\n    \"bounds\": [0, 0, 24000, 24000],\n    \"center\": [12000, 12000, 0],\n    \"vector_layers\": [\n        {\n            \"id\": \"Tile_layer\",\n            \"description\": \"Tile layer\",\n            \"minzoom\": 0,\n            \"maxzoom\": 10,\n            \"fields\": {\n              \"plate\": \"String\",\n              \"image\": \"String\",\n              \"label\": \"Number\",\n              \"channel\": \"Number\"\n            }\n        }\n    ],\n    \"fillzoom\": 3,\n    \"multiscale\": {\n        \"axes\": [\n            {\n                \"name\": \"x\",\n                \"unit\": \"micrometer\",\n                \"type\": \"space\",\n                \"description\": \"x-axis\"\n            },\n            {\n                \"name\": \"y\",\n                \"unit\": \"micrometer\",\n                \"type\": \"space\",\n                \"description\": \"y-axis\"\n            }\n        ],\n        \"transformationMatrix\": [\n            [\n                1.0,\n                0.0,\n                0.0\n            ],\n            [\n                0.0,\n                1.0,\n                0.0\n            ],\n            [\n                0.0,\n                0.0,\n                0.0\n            ]\n        ]\n    }\n}\n</code></pre>"},{"location":"tiling/#tiled-binary-tilejson","title":"Tiled binary TileJSON","text":"<p>In addition to json format, tiles may be encoded in a binary protobuf format. Below follows a similar example to the one above, but with binary tiles. The <code>tiles</code> property specifies the URL pattern for accessing the binary tiles, which in this case is a 2D data set (no channels, time or z-axis) with zoom level. The <code>fillzoom</code> property specifies the zoom level from which to generate overzoomed tiles, which in this case starts at level 3, after the last specified layer.</p> <pre><code>{\n    \"tilejson\": \"3.0.0\",\n    \"name\": \"2D Data Example\",\n    \"description\": \"A tileset showing 2D data with multiple layers of detail.\",\n    \"version\": \"1.0.0\",\n    \"attribution\": \"&lt;a href='http://example.com'&gt;Example&lt;/a&gt;\",\n    \"tiles\": [\n        \"http://example.com/tiled_example/{zlvl}/{x}/{y}.pbf\"\n    ],\n    \"minzoom\": 0,\n    \"maxzoom\": 10,\n    \"bounds\": [0, 0, 24000, 24000],\n    \"center\": [12000, 12000, 0],\n    \"vector_layers\": [\n        {\n            \"id\": \"tile_layer\",\n            \"description\": \"Tile layer\",\n            \"minzoom\": 0,\n            \"maxzoom\": 10,\n            \"fields\": {\n              \"plate\": \"String\",\n              \"image\": \"String\",\n              \"label\": \"Number\",\n              \"channel\": \"Number\",\n            },\n            \"fieldranges\": {\n              \"label\": [0,100],\n              \"channel\": [0,10]\n            },\n            \"fieldenums\": {\n              \"plate\": [\"A1\", \"A2\", \"B1\", \"B2\"],\n              \"image\": [\"image1.tif\", \"image2.tif\", \"image3.tif\"],\n            }\n            \"fielddescriptions\": {\n              \"plate\": \"Well plate identifier\",\n              \"image\": \"Image filename\",\n              \"label\": \"Label identifier\",\n              \"channel\": \"Channel identifier\"\n            }\n        }\n    ],\n    \"fillzoom\": 3\n}\n</code></pre>"},{"location":"tiling/#tiled-binary-example","title":"Tiled binary example","text":"<p>The examples folder contains an example of how to generate binary tiles from one large MicroJSON file. It uses a helper module that generates a large random polygon grid, as could be expected in an imaging setting, using typical imaging coordinates. It is also included below for reference.</p>"},{"location":"tiling/#example-of-creating-binary-tiles-from-a-large-microjson-file","title":"Example of creating binary tiles from a large MicroJSON file","text":"Source code in <code>src/microjson/examples/tiling.py</code> <pre><code>def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"microjson_data_path\", nargs='?',\n                        default=\"\",\n                        help=\"Path to the MicroJSON data file\")\n    args = parser.parse_args()\n\n    if args.microjson_data_path:\n        microjson_data_path = args.microjson_data_path\n        do_generate = False\n\n        # Extract fields, ranges, enums from the provided MicroJSON\n        field_names, field_ranges, field_enums = extract_fields_ranges_enums(\n            microjson_data_path)\n\n        # Create a TileLayer including the extracted fields\n        vector_layers = [\n            TileLayer(\n                id=\"extracted-layer\",\n                fields=field_names,\n                minzoom=0,\n                maxzoom=10,\n                description=\"Layer with extracted fields\",\n                fieldranges=field_ranges,\n                fieldenums=field_enums,\n            )\n        ]\n    else:\n        microjson_data_path = \"example.json\"\n        do_generate = True\n\n    # clear the tiles directory\n    os.system(\"rm -rf tiles\")\n\n    # create the tiles directory\n    os.makedirs(\"tiles\")\n\n    if do_generate:\n        # Create a microjson file with random polygons\n        GRID_SIZE = 10000\n        CELL_SIZE = 100\n        MIN_VERTICES = 10\n        MAX_VERTICES = 100\n        meta_types = {\n            \"num_vertices\": \"int\",\n        }\n        meta_values_options = {\n            \"polytype\": [\"Type1\", \"Type2\", \"Type3\", \"Type4\"]\n        }\n\n        vector_layers = [\n            TileLayer(\n                id=\"polygon-layer\",\n                fields={\"id\": \"String\", \"polytype\": \"String\"},\n                minzoom=0,\n                maxzoom=10,\n                description=\"Layer containing polygon data\",\n                fieldranges={\n                    \"num_vertices\": [10, 100]\n                },\n                fieldenums={\n                    \"polytype\": [\"Type1\", \"Type2\", \"Type3\", \"Type4\"]\n                },\n            )\n        ]\n\n        generate_polygons(\n            GRID_SIZE,\n            CELL_SIZE,\n            MIN_VERTICES,\n            MAX_VERTICES,\n            meta_types,\n            meta_values_options,\n            microjson_data_path\n        )\n\n    # get bounds\n    maxbounds = getbounds(microjson_data_path, square=True)\n\n    center = [0,\n              (maxbounds[0] + maxbounds[2]) / 2,\n              (maxbounds[1] + maxbounds[3]) / 2]\n\n    # Instantiate TileModel with your settings\n    tile_model = TileModel(\n        tilejson=\"3.0.0\",\n        tiles=[Path(\"tiles/{z}/{x}/{y}.pbf\")],  # Local path or URL\n        name=\"Example Tile Layer\",\n        description=\"A TileJSON example incorporating MicroJSON data\",\n        version=\"1.0.0\",\n        attribution=\"Polus AI\",\n        minzoom=0,\n        maxzoom=7,\n        bounds=maxbounds,\n        center=center,\n        vector_layers=vector_layers\n    )\n\n    # Create the root model with your TileModel instance\n    tileobj = TileJSON(root=tile_model)\n\n    # export to tilejson\n    os.makedirs(\"tiles\", exist_ok=True)\n    with open(\"tiles/metadata.json\", \"w\") as f:\n        f.write(tileobj.model_dump_json(indent=2))\n\n    # Initialize the TileHandler\n    handler = TileWriter(tile_model, pbf=True)\n    handler.microjson2tiles(microjson_data_path, validate=False)\n</code></pre>"},{"location":"tiling/#tiled-microjson-example","title":"Tiled MicroJSON Example","text":""},{"location":"tiling/#level-0","title":"Level 0","text":"<p>The following is an example of a MicroJSON object at zoom level 0, tile at (0,0) in the tiling scheme. Example URL: <code>http://example.com/tiles/0/0/0.json</code></p> <pre><code>{\n    \"tilejson\": \"3.0.0\",\n    \"name\": \"2D Data Example\",\n    \"description\": \"A tileset showing 2D data with multiple layers of detail.\",\n    \"version\": \"1.0.0\",\n    \"attribution\": \"&lt;a href='http://example.com'&gt;Example&lt;/a&gt;\",\n    \"tiles\": [\n        \"http://example.com/tiled_example/{zlvl}/{x}/{y}.json\"\n    ],\n    \"minzoom\": 0,\n    \"maxzoom\": 10,\n    \"bounds\": [0, 0, 24000, 24000],\n    \"center\": [12000, 12000, 0],\n    \"format\": \"json\",\n    \"vector_layers\": [\n        {\n            \"id\": \"image_layer\",\n            \"description\": \"Image layer\",\n            \"minzoom\": 0,\n            \"maxzoom\": 10,\n            \"fields\": {\n              \"plate\": \"String\",\n              \"image\": \"String\",\n              \"label\": \"Number\",\n              \"channel\": \"Number\"\n            }\n        }\n    ],\n    \"fillzoom\": 3\n}\n</code></pre>"},{"location":"tiling/#level-1","title":"Level 1","text":"<p>The following is an example of a MicroJSON object at zoom level 1, tile at (0,1) in the tiling scheme. Example URL: <code>http://example.com/tiles/1/0/1.json</code></p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              0,\n              10000\n            ],\n            [\n              10000,\n              10000\n            ],\n            [\n              10000,\n              20000\n            ],\n            [\n              0,\n              20000\n            ],\n            [\n              0,\n              10000\n            ]\n          ]\n        ]\n      },\n      \"properties\": {\n        \"label\": 3\n      }\n    }\n  ],\n  \"multiscale\": {\n    \"axes\": [\n      {\n        \"name\": \"x\",\n        \"type\": \"space\",\n        \"unit\": \"micrometer\",\n        \"description\": \"x-axis\"\n      },\n      {\n        \"name\": \"y\",\n        \"type\": \"space\",\n        \"unit\": \"micrometer\",\n        \"description\": \"y-axis\"\n      }\n    ]\n  },\n  \"properties\": {\n    \"plate\": \"label\",\n    \"image\": \"x00_y01_p01_c1.ome.tif\",\n    \"channel\": 1.0\n  }\n}\n</code></pre>"},{"location":"tiling/#level-2","title":"Level 2","text":"<p>The following is an example of a MicroJSON object at zoom level 2, tile at (1,1) in the tiling scheme. Example URL: <code>http://example.com/tiles/2/1/3.json</code></p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              5000,\n              15000\n            ],\n            [\n              10000,\n              15000\n            ],\n            [\n              10000,\n              20000\n            ],\n            [\n              5000,\n              20000\n            ],\n            [\n              5000,\n              15000\n            ]\n          ]\n        ]\n      },\n      \"properties\": {\n        \"label\": 13\n      }\n    }\n  ],\n  \"multiscale\": {\n    \"axes\": [\n      {\n        \"name\": \"x\",\n        \"type\": \"space\",\n        \"unit\": \"micrometer\",\n        \"description\": \"x-axis\"\n      },\n      {\n        \"name\": \"y\",\n        \"type\": \"space\",\n        \"unit\": \"micrometer\",\n        \"description\": \"y-axis\"\n      }\n    ]\n  },\n  \"properties\": {\n    \"plate\": \"label\",\n    \"image\": \"x00_y01_p01_c1.ome.tif\",\n    \"channel\": 1.0\n  }\n}\n</code></pre>"},{"location":"tiling_demo/","title":"MicroJSON Tiling Demo","text":"<p>This notebook demonstrates how to use the MicroJSON tiling functionality to create vector tiles from MicroJSON data. Vector tiles are a way to efficiently store and serve geospatial data for web mapping applications.</p>"},{"location":"tiling_demo/#overview","title":"Overview","text":"<p>In this demo, we will: 1. Generate sample polygon data (or use existing MicroJSON data) 2. Create a TileJSON specification 3. Generate vector tiles from the MicroJSON data 4. Save the tiles and metadata for use in web mapping applications</p>"},{"location":"tiling_demo/#import-required-libraries","title":"Import Required Libraries","text":"<p>First, let's import the necessary libraries for tiling MicroJSON data.</p> <pre><code>from microjson.tilewriter import (\n    TileWriter,\n    getbounds,\n    extract_fields_ranges_enums\n)\nfrom pathlib import Path\nfrom microjson.tilemodel import TileJSON, TileModel, TileLayer\nimport os\nfrom microjson.polygen import generate_polygons\nimport json\n</code></pre>"},{"location":"tiling_demo/#option-1-generate-sample-polygon-data","title":"Option 1: Generate Sample Polygon Data","text":"<p>If you don't have existing MicroJSON data, we can generate sample polygon data using the <code>generate_polygons</code> function.</p> <pre><code># Parameters for generating polygons\nGRID_SIZE = 10000  # Size of the grid\nCELL_SIZE = 100    # Size of each cell in the grid\nMIN_VERTICES = 10  # Minimum number of vertices per polygon\nMAX_VERTICES = 100 # Maximum number of vertices per polygon\n\n# Metadata types and options\nmeta_types = {\n    \"num_vertices\": \"int\",\n}\nmeta_values_options = {\n    \"polytype\": [\"Type1\", \"Type2\", \"Type3\", \"Type4\"]\n}\n\n# Output file path\nmicrojson_data_path = \"example_generated.json\"\n\n# Generate polygons\ngenerate_polygons(\n    GRID_SIZE,\n    CELL_SIZE,\n    MIN_VERTICES,\n    MAX_VERTICES,\n    meta_types,\n    meta_values_options,\n    microjson_data_path\n)\n\nprint(f\"Generated polygon data saved to {microjson_data_path}\")\n</code></pre> <pre><code>Generated polygon data saved to example_generated.json\n</code></pre>"},{"location":"tiling_demo/#option-2-use-existing-microjson-data","title":"Option 2: Use Existing MicroJSON Data","text":"<p>Alternatively, you can use existing MicroJSON data. Uncomment and modify the following cell to use your own data.</p> <pre><code># microjson_data_path = \"path/to/your/data.json\"\n# print(f\"Using existing MicroJSON data from {microjson_data_path}\")\n</code></pre>"},{"location":"tiling_demo/#visualize-the-microjson-data","title":"Visualize the MicroJSON Data","text":"<p>Let's take a look at the structure of our MicroJSON data.</p> <pre><code># Load and display the first few features of the MicroJSON data\nwith open(microjson_data_path, 'r') as f:\n    data = json.load(f)\n\n# Display basic information about the data\nprint(f\"Number of features: {len(data.get('features', []))}\")\n\n# Display the first feature (truncated for readability)\nif 'features' in data and len(data['features']) &gt; 0:\n    first_feature = data['features'][0]\n    print(\"\\nSample feature:\")\n    print(json.dumps(first_feature, indent=2)[:500] + \"...\")\n</code></pre> <pre><code>Number of features: 10000\n\nSample feature:\n{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n      [\n        [\n          62.7619624272948,\n          9.7445327252005\n        ],\n        [\n          66.55786998050925,\n          10.453250162004622\n        ],\n        [\n          86.82803641255592,\n          51.64994084555056\n        ],\n        [\n          77.93853896392383,\n          68.85236038607228\n        ],\n        [\n          67.57602296868663,\n          78.79357410969412\n        ],\n        [\n          4...\n</code></pre>"},{"location":"tiling_demo/#extract-fields-ranges-and-enums","title":"Extract Fields, Ranges, and Enums","text":"<p>For existing MicroJSON data, we can extract field information, value ranges, and enumeration values.</p> <pre><code># Extract fields, ranges, and enums from the MicroJSON data\nfield_names, field_ranges, field_enums = extract_fields_ranges_enums(microjson_data_path)\n\nprint(\"Extracted field names:\")\nprint(field_names)\n\nprint(\"\\nExtracted field ranges:\")\nprint(field_ranges)\n\nprint(\"\\nExtracted field enums:\")\nprint(field_enums)\n</code></pre> <pre><code>Extracted field names:\n{'num_vertices': 'Number', 'polytype': 'String'}\n\nExtracted field ranges:\n{'num_vertices': [10, 24]}\n\nExtracted field enums:\n{'polytype': {'Type3', 'Type2', 'Type1', 'Type4'}}\n</code></pre>"},{"location":"tiling_demo/#define-vector-layers","title":"Define Vector Layers","text":"<p>Now, let's define the vector layers for our tiles. We'll use the extracted field information.</p> <pre><code># Create a TileLayer using the extracted fields\nvector_layers = [\n    TileLayer(\n        id=\"polygon-layer\",\n        fields=field_names,\n        minzoom=0,\n        maxzoom=10,\n        description=\"Layer containing polygon data\",\n        fieldranges=field_ranges,\n        fieldenums=field_enums,\n    )\n]\n\nprint(\"Vector layer defined with the following properties:\")\nprint(f\"ID: {vector_layers[0].id}\")\nprint(f\"Fields: {vector_layers[0].fields}\")\nprint(f\"Zoom range: {vector_layers[0].minzoom} - {vector_layers[0].maxzoom}\")\n</code></pre> <pre><code>Vector layer defined with the following properties:\nID: polygon-layer\nFields: {'num_vertices': 'Number', 'polytype': 'String'}\nZoom range: 0 - 10\n</code></pre>"},{"location":"tiling_demo/#get-bounds-and-center","title":"Get Bounds and Center","text":"<p>Next, we'll calculate the bounds of our data to properly configure the tile model.</p> <pre><code># Get bounds of the data (square=True ensures the bounds form a square)\nmaxbounds = getbounds(microjson_data_path, square=True)\nprint(f\"Bounds: {maxbounds}\")\n\n# Calculate the center of the bounds\ncenter = [0, (maxbounds[0] + maxbounds[2]) / 2, (maxbounds[1] + maxbounds[3]) / 2]\nprint(f\"Center: {center}\")\n</code></pre> <pre><code>Bounds: [5.352408515784582, 5.049442955279417, 9995.190828709661, 9994.887863149157]\nCenter: [0, 5000.271618612723, 4999.9686530522185]\n</code></pre>"},{"location":"tiling_demo/#create-the-tile-model","title":"Create the Tile Model","text":"<p>Now, let's create the TileModel that will define our tile set.</p> <pre><code># Create output directory for tiles\nos.makedirs(\"tiles\", exist_ok=True)\n\n# Instantiate TileModel with our settings\ntile_model = TileModel(\n    tilejson=\"3.0.0\",\n    tiles=[Path(\"tiles/{z}/{x}/{y}.pbf\")],  # Local path or URL\n    name=\"Example Tile Layer\",\n    description=\"A TileJSON example incorporating MicroJSON data\",\n    version=\"1.0.0\",\n    attribution=\"Polus AI\",\n    minzoom=0,\n    maxzoom=7,\n    bounds=maxbounds,\n    center=center,\n    vector_layers=vector_layers\n)\n\n# Create the root model with our TileModel instance\ntileobj = TileJSON(root=tile_model)\n\n# Display the TileJSON specification\nprint(\"TileJSON specification:\")\nprint(tileobj.model_dump_json(indent=2))\n</code></pre> <pre><code>TileJSON specification:\n{\n  \"tilejson\": \"3.0.0\",\n  \"tiles\": [\n    \"tiles/{z}/{x}/{y}.pbf\"\n  ],\n  \"name\": \"Example Tile Layer\",\n  \"description\": \"A TileJSON example incorporating MicroJSON data\",\n  \"version\": \"1.0.0\",\n  \"attribution\": \"Polus AI\",\n  \"template\": null,\n  \"legend\": null,\n  \"scheme\": null,\n  \"grids\": null,\n  \"data\": null,\n  \"minzoom\": 0,\n  \"maxzoom\": 7,\n  \"bounds\": [\n    5.352408515784582,\n    5.049442955279417,\n    9995.190828709661,\n    9994.887863149157\n  ],\n  \"center\": [\n    0.0,\n    5000.271618612723,\n    4999.9686530522185\n  ],\n  \"fillzoom\": null,\n  \"vector_layers\": [\n    {\n      \"id\": \"polygon-layer\",\n      \"fields\": {\n        \"num_vertices\": \"Number\",\n        \"polytype\": \"String\"\n      },\n      \"minzoom\": 0,\n      \"maxzoom\": 10,\n      \"description\": \"Layer containing polygon data\",\n      \"fieldranges\": {\n        \"num_vertices\": [\n          10,\n          24\n        ]\n      },\n      \"fieldenums\": {\n        \"polytype\": [\n          \"Type3\",\n          \"Type2\",\n          \"Type1\",\n          \"Type4\"\n        ]\n      },\n      \"fielddescriptions\": null\n    }\n  ],\n  \"multiscale\": null,\n  \"scale_factor\": null\n}\n</code></pre>"},{"location":"tiling_demo/#export-tilejson-metadata","title":"Export TileJSON Metadata","text":"<p>Let's export the TileJSON metadata to a file.</p> <pre><code># Export to tilejson\nwith open(\"tiles/metadata.json\", \"w\") as f:\n    f.write(tileobj.model_dump_json(indent=2))\n\nprint(\"TileJSON metadata exported to tiles/metadata.json\")\n</code></pre> <pre><code>TileJSON metadata exported to tiles/metadata.json\n</code></pre>"},{"location":"tiling_demo/#generate-vector-tiles","title":"Generate Vector Tiles","text":"<p>Finally, let's generate the vector tiles from our MicroJSON data.</p> <pre><code># Initialize the TileWriter\nhandler = TileWriter(tile_model, pbf=True)\n\n# Convert MicroJSON to tiles\nhandler.microjson2tiles(microjson_data_path, validate=False)\n\nprint(\"Vector tiles generated successfully!\")\n\n# List the generated tile directories to verify\ntile_dirs = [d for d in os.listdir(\"tiles\") if os.path.isdir(os.path.join(\"tiles\", d))]\nprint(f\"Generated tile zoom levels: {tile_dirs}\")\n</code></pre> <pre><code>Vector tiles generated successfully!\nGenerated tile zoom levels: ['7', '2', '0', 'tiled_example', '1', '5', '3', '4', '6']\n</code></pre>"},{"location":"tiling_demo/#conclusion","title":"Conclusion","text":"<p>In this notebook, we've demonstrated how to:</p> <ol> <li>Generate or use existing MicroJSON data</li> <li>Extract field information from the data</li> <li>Define vector layers for our tiles</li> <li>Calculate bounds and center for our tile set</li> <li>Create a TileJSON specification</li> <li>Generate vector tiles from MicroJSON data</li> </ol> <p>These vector tiles can now be used in web mapping applications like Mapbox GL JS, Leaflet, or OpenLayers to display the data interactively.</p>"},{"location":"usage/","title":"Create MicroJSON models","text":"<p>In this tutorial, we explain how a Python script is used to convert a pandas DataFrame into a MicroJSON FeatureCollection object.</p>"},{"location":"usage/#example-dataframe-to-microjson-conversion","title":"Example dataframe to MicroJSON conversion","text":"<p>Transforms a pandas DataFrame into a FeatureCollection model.</p> <p>This function is designed to convert geometries stored in a pandas DataFrame into a FeatureCollection model, based on the MicroJSON schema.</p> <p>Parameters: - df: The pandas DataFrame to transform. Each row should represent a feature.</p> <p>Returns: - A FeatureCollection object that aggregates the individual features.</p> Source code in <code>src/microjson/examples/df_to_microjson.py</code> <pre><code>def df_to_microjson(df: pd.DataFrame) -&gt; mj.FeatureCollection:\n    \"\"\"\n    Transforms a pandas DataFrame into a FeatureCollection model.\n\n    This function is designed to convert geometries stored in a pandas\n    DataFrame into a FeatureCollection model, based on the MicroJSON schema.\n\n    Parameters:\n    - df: The pandas DataFrame to transform. Each row should represent a\n    feature.\n\n    Returns:\n    - A FeatureCollection object that aggregates the individual features.\n\n    \"\"\"\n    # Initialize a list to hold the Feature objects\n    features: List[mj.Feature] = []\n\n    # Iterate over each row in the DataFrame\n    for _, row in df.iterrows():\n        # Dynamically generate a Geometry object based on the row's\n        # geometry type\n        GeometryClass = getattr(mj, row[\"geometryType\"])\n        geometry = GeometryClass(\n            type=row[\"geometryType\"], coordinates=row[\"coordinates\"]\n        )\n        properties = {}\n        for key in [\"name\", \"value\", \"values\"]:\n            properties[key] = row[key]\n\n        # Generate a Feature object that combines geometry and properties\n        feature = mj.MicroFeature(\n            type=row[\"type\"], geometry=geometry, properties=properties\n        )\n\n        # Append this feature to the list of features\n        features.append(feature)\n\n    # Generate a FeatureCollection object to aggregate all features\n    feature_collection = mj.MicroFeatureCollection(\n        type=\"FeatureCollection\",\n        features=features,\n        properties={\"plate\": \"Example Plate\"}\n    )\n\n    return feature_collection\n</code></pre> <p>Here's a breakdown of the steps involved:</p> <ol> <li> <p>Initialize an empty list of Features: A list <code>features</code> is initialized to hold <code>Feature</code> objects.</p> </li> <li> <p>Iterate over DataFrame rows: The function iterates through each row of the DataFrame, performing the following operations for each row:</p> <ul> <li> <p>Create a Geometry Object: It dynamically generates a Geometry object based on the geometry type specified in the row.</p> </li> <li> <p>Create a Properties Object: It then creates a <code>Properties</code> object to hold metadata about the feature like the name, value, and an array of values.</p> </li> <li> <p>Combine into a Feature: It combines both the geometry and properties into a MicroJSON <code>Feature</code> object.</p> </li> </ul> </li> <li> <p>Calculate Value Ranges: For each numeric attribute, a range of values (min, max) is calculated.</p> </li> <li> <p>Create a FeatureCollection Object: Finally, it aggregates all the features into a MicroJSON <code>FeatureCollection</code> object, including the calculated value ranges and other optional metadata.</p> </li> </ol>"},{"location":"usage/#example-dataframe-creation-conversion-and-microjson-output","title":"Example dataframe creation, conversion and MicroJSON output","text":"<p>Below, we convert a pandas DataFrame into a MicroJSON FeatureCollection object. It includes an example of creating a DataFrame with two features, one Point and one Polygon, and converting it into a FeatureCollection model using the <code>df_to_microjson</code> function as described above, and then serializing the model to a JSON string.</p> <pre><code>if __name__ == \"__main__\":\n    # Example DataFrame with two features: one Point and one Polygon\n    data = [\n        {\n            \"type\": \"Feature\",\n            \"geometryType\": \"Point\",\n            \"coordinates\": [0, 0],\n            \"name\": \"Point 1\",\n            \"value\": 1,\n            \"values\": [1, 2, 3],\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometryType\": \"Polygon\",\n            \"coordinates\": [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]],\n            \"name\": \"Polygon 1\",\n            \"value\": 2,\n            \"values\": [4, 5, 6],\n        },\n    ]\n\n    # Convert this list of dictionaries into a DataFrame\n    df = pd.DataFrame(data)\n\n    # Convert the DataFrame into a FeatureCollection model\n    feature_collection_model = df_to_microjson(df)\n\n    # Serialize the FeatureCollection model to a JSON string\n    print(\n        feature_collection_model.model_dump_json(indent=2, exclude_unset=True)\n    )\n</code></pre>"},{"location":"validation/","title":"Working with MicroJSON and GeoJSON Files in Python","text":"<p>In this tutorial, we'll explore how to validate MicroJSON and GeoJSON files using the <code>microjson</code> package, which leverages Pydantic for data validation. Validation ensures that your JSON files adhere to the specified structure and constraints.</p>"},{"location":"validation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li><code>microjson</code> package</li> </ul>"},{"location":"validation/#code-explanation","title":"Code Explanation","text":"<p>Before we dive into the code, let's understand what it aims to accomplish:</p> <ol> <li>Load JSON File: Reads a JSON file into a Python object.</li> <li>Validate JSON Structure: Utilizes Pydantic models to validate the structure of the JSON object.</li> <li>Print Result: Prints the validated Pydantic object to the console.</li> </ol> <p>Now let's look at the code itself.</p> <pre><code>import microjson.model as mj\nimport json\n\n# load the microjson file\nwith open('tests/json/microjson/valid/fullexample.json') as f:\n    data = json.load(f, strict=True)\n\n# validate the microjson file\nmicrojsonobj = mj.MicroJSON.model_validate(data)\nprint(\"done validating: {}\".format(microjsonobj))\n\n# load the geojson file\nwith open('tests/json/geojson/valid/featurecollection/basic.json') as f:\n    data = json.load(f, strict=True)\n\n# validate the geojson file\ngeojsonobj = mj.GeoJSON.model_validate(data)\n\nprint(\"done validating: {}\".format(geojsonobj))\n</code></pre>"},{"location":"validation/#step-by-step-explanation","title":"Step by Step Explanation","text":"<ol> <li> <p>Import Modules: The script imports required modules from the <code>microjson</code> package and Python's built-in <code>json</code> library.</p> </li> <li> <p>Read and Validate MicroJSON:</p> <ul> <li>Opens a MicroJSON file in read mode.</li> <li>Uses <code>json.load()</code> to parse the JSON content.</li> <li>Calls <code>model_validate()</code> from the <code>microjson</code> package to validate the JSON against the MicroJSON Pydantic model.</li> </ul> </li> <li> <p>Read and Validate GeoJSON:</p> <ul> <li>Similar to the MicroJSON validation but validates against the GeoJSON Pydantic model.</li> </ul> </li> <li> <p>Output: If the validation is successful, the script will print the validated objects.</p> </li> </ol> <p>By following this approach, you can validate the structure of any MicroJSON or GeoJSON file against their respective Pydantic models.</p>"}]}